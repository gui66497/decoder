{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///ng-table.min.js","webpack:///webpack/bootstrap f72b9990c4e9da3f352c","webpack:///external \"angular\"","webpack:///./src/core/index.ts","webpack:///./src/browser/index.ts","webpack:///./src/core/data/index.ts","webpack:///./src/core/ngTableDefaults.ts","webpack:///./src/core/ngTableEventsChannel.ts","webpack:///./src/core/ngTableParams.ts","webpack:///./src/core/ngTableSettings.ts","webpack:///./src/core/util.ts","webpack:///./src/browser/ngTable.directive.ts","webpack:///./src/browser/ngTableColumn.ts","webpack:///./src/browser/ngTableColumnsBinding.directive.ts","webpack:///./src/browser/ngTableController.ts","webpack:///./src/browser/ngTableDynamic.directive.ts","webpack:///./src/browser/ngTableFilterConfig.ts","webpack:///./src/browser/ngTableFilterRow.directive.ts","webpack:///./src/browser/ngTableFilterRowController.ts","webpack:///./src/browser/ngTableGroupRow.directive.ts","webpack:///./src/browser/ngTableGroupRowController.ts","webpack:///./src/browser/ngTablePagination.directive.ts","webpack:///./src/browser/ngTableSelectFilterDs.directive.ts","webpack:///./src/browser/ngTableSorterRow.directive.ts","webpack:///./src/browser/ngTableSorterRowController.ts","webpack:///./src/core/data/ngTableDefaultGetData.ts","webpack:///./src/core/filtering/index.ts","webpack:///./src/core/grouping/index.ts","webpack:///./src/core/grouping/ngTableDefaultGetGroups.ts","webpack:///./src/core/grouping/publicExports.ts","webpack:///./src/browser/filterRow.html","webpack:///./src/browser/filters/number.html","webpack:///./src/browser/filters/select-multiple.html","webpack:///./src/browser/filters/select.html","webpack:///./src/browser/filters/text.html","webpack:///./src/browser/groupRow.html","webpack:///./src/browser/header.html","webpack:///./src/browser/pager.html","webpack:///./src/browser/sorterRow.html","webpack:///./index.ts"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_0__","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__export","angular","data_1","grouping_1","ngTableDefaults_1","ngTableSettings_1","ngTableParams_1","ngTableEventsChannel_1","ngTableCoreModule","provider","NgTableDefaultGetDataProvider","ngTableDefaultGetGroups","ngTableDefaults","service","NgTableEventsChannel","NgTableSettings","run","NgTableParams","init","ngTableDefaults_2","IDefaults","ngTableSettings_2","ISettings","ngTable_directive_1","ngTableColumn_1","ngTableColumnsBinding_directive_1","ngTableController_1","NgTableController","ngTableDynamic_directive_1","ngTableFilterConfig_1","NgTableFilterConfigProvider","NgTableFilterConfig","ngTableFilterRow_directive_1","ngTableFilterRowController_1","ngTableGroupRow_directive_1","ngTableGroupRowController_1","ngTablePagination_directive_1","ngTableSelectFilterDs_directive_1","ngTableSorterRow_directive_1","ngTableSorterRowController_1","ngTableBrowserModule","directive","ngTable","NgTableColumn","ngTableColumnsBinding","controller","ngTableDynamic","ngTableFilterRow","NgTableFilterRowController","ngTableGroupRow","NgTableGroupRowController","ngTablePagination","ngTableSelectFilterDs","ngTableSorterRow","NgTableSorterRowController","params","settings","ng1","$rootScope","events","addTableParamsEvent","eventName","target","fnName","charAt","toUpperCase","substring","event","_a","createEventSubscriptionFn","createPublishEventFn","extend","_this","args","_i","arguments","length","$broadcast","apply","concat","createEventSelectorFn","eventSelector","isEventSelectorFunc","publisher","val","isScopeLike","$new","handler","eventSelectorOrScope","actualEvtSelector","scope","$on","eventArgs","isNullInstance","fnArgs","$inject","isNumber","isNaN","parseFloat","isFinite","util_1","baseParameters","baseSettings","data","defaultSettings","ngTableSettings","createDefaults","isCommittedDataset","initialEvents","_params","page","count","filter","sorting","group","_settings","reloadPages","currentPages","oldPages","newPages","generatePagesArray","total","equals","ngTableEventsChannel","publishPagesChanged","parameters","publishAfterCreated","forEach","undefined","keys","significantFilter","filterValue","currentPage","totalItems","pageSize","maxBlocks","maxPage","maxPivotPages","minPage","numPages","pages","Math","ceil","push","type","number","max","active","current","round","paginationMaxBlocks","paginationMinBlocks","min","sortDirection","newParameters","isGroupingFun","hasErrorState","errParamsMemento","createComparableParams","hasFilter","hasFilterChanges","previousFilter","prevParamsMemento","hasGlobalSearchFieldChanges","hasGroup","indexOf","isDataReloadRequired","isSortBy","field","direction","orderBy","convertSortToOrderBy","parseParamsFromUrl","key","split","reverse","lastKey","len","v","parseGroup","log","reload","pData","$loading","copy","runInterceptorPipeline","$q","when","getGroups","fn","getData","oldData","then","publishAfterReloadData","catch","reason","reject","newSettings","isDefined","merge","originalDataset_1","dataset","hasDatasetChanged","fireEvent","publishDatasetChanged","url","asString","collectValue","isArray","pairs","encodeURIComponent","isSignificantValue","item","subkey","pname","isFunction","groupSortDirection","currentVal","previousVal","debugMode","$log","debug","defaultSort","groupOptions","fetchedData","interceptors","reduce","result","interceptor","thenFn","response","bind","rejectFn","responseError","ngTableDefaultGetData","defaults","counts","filterOptions","filterComparator","filterDelay","filterDelayThreshold","filterFilterName","filterFn","filterLayout","isExpanded","sortingIndicator","existing","results","optimizeFilterDelay","column","$parse","restrict","priority","compile","element","dataRow","groupRow","columns","rows","find","tr","hasClass","el","attr","getAttrValue","setAttrValue","parsedAttribute","expr","localValue","context","assign","$scope","parsedExpr","$parent","titleExpr","id","title","titleAlt","headerTitle","sortable","class","groupable","headerTemplateURL","filterData","show","attrs","$columns","buildColumns","setupBindingsToInternalScope","loadFilterData","compileDirectiveTemplates","buildColumn","defaultScope","extendedCol","create","_loop_1","prop","getterSetter","getterFn","$column","localValue_1","wrappedGetterFn_1","createGetterSetter","noop","initialValue","newValue","linkFn","$element","$attrs","setter","$watch","newColumns","shallowClone","slice","link","core_1","$timeout","$compile","$document","ngTableColumn","$filterRow","disabled","delayFilter","timer","callback","ms","cancel","newParams","oldParams","subscribeToTableEvents","some","onDataReloadStatusChange","newStatus","currentParams","applyFilter","templates","header","templateHeader","pagination","templatePagination","addClass","headerTemplate","theadFound_1","children","e","tagName","prepend","paginationTemplate","after","isPromiseLike","isObject","col","parseNgTableDynamicExpr","parts","tableParams","Error","tableParamsExpr","setupFilterRowBindingsToInternalScope","setupGroupRowBindingsToInternalScope","showFilter","show_filter","hasVisibleFilterColumn","disableFilter","$groupRow","showGroup","showGroupGetter_1","getVisibleColumns","onAfterReloadData","newDatapage","visibleColumns","$groups","visibleColumnCount","$data","onPagesChanged","array","predicate","found","obj","tElement","row","showExpr","$watchCollection","newCols","$injector","defaultConfig","defaultBaseUrl","defaultExt","aliasUrls","$get","instantiate","config","resetConfigs","setConfig","customConfig","mergeConfig","getUrlForAlias","aliasName","filterKey","getTemplateUrl","filterDef","filterName","replace","templateUrl","controllerAs","ngTableFilterConfig","getFilterPlaceholderValue","getFilterCellCss","layout","size","width","parseInt","toString","placeholder","groupFns","newGrouping","setGroup","getGroupables","groupableCols","getGroupTitle","isGroupingFunc","groupBy","isSelectedGroup","changeSortDirection","$selGroup","toggleDetail","newDirection","findGroupColumn","groupKey","grouping","existingGroupCol","$selGroupTitle","groupedColumn","pubParams","template","append","NgTableSelectFilterDsController","bindDataSource","getSelectListData","hasEmptyOption","unshift","$selectData","isMatch","dataInput","Array","sortBy","parsedSortable","inverseSort","sortingParams","ctrlKey","metaKey","$filter","getFilterFn","getOrderByFn","sortingFilterName","filterKeys","parsedFilter","setPath","applyPaging","pagedData","applySort","orderByFn","options","defaultDataOptions","dataOptions","fData","publishAfterDataFiltered","orderedData","publishAfterDataSorted","path","ret","parentPathKeys","groupFn","groupField_1","getPath","originalDataOptions","gotData","groups","groupName","$hideRows","finally","ks","html","put","browser_1","ngTableModule"],"mappings":"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","file":"ng-table.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"angular\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"angular\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ng-table\"] = factory(require(\"angular\"));\n\telse\n\t\troot[\"ng-table\"] = factory(root[\"angular\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_0__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"angular\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"angular\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ng-table\"] = factory(require(\"angular\"));\n\telse\n\t\troot[\"ng-table\"] = factory(root[\"angular\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_0__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmory imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmory exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 51);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nvar angular = __webpack_require__(0);\nvar data_1 = __webpack_require__(3);\nvar grouping_1 = __webpack_require__(37);\nvar ngTableDefaults_1 = __webpack_require__(7);\nvar ngTableSettings_1 = __webpack_require__(10);\nvar ngTableParams_1 = __webpack_require__(9);\nvar ngTableEventsChannel_1 = __webpack_require__(8);\nvar ngTableCoreModule = angular.module('ngTable-core', [])\n    .provider('ngTableDefaultGetData', data_1.NgTableDefaultGetDataProvider)\n    .factory('ngTableDefaultGetGroups', grouping_1.ngTableDefaultGetGroups)\n    .value('ngTableDefaults', ngTableDefaults_1.ngTableDefaults)\n    .service('ngTableEventsChannel', ngTableEventsChannel_1.NgTableEventsChannel)\n    .service('ngTableSettings', ngTableSettings_1.NgTableSettings)\n    .run(ngTableParams_1.NgTableParams.init);\nexports.ngTableCoreModule = ngTableCoreModule;\n// note: if you are using ES6 or typescript prefer:\n// import { NgTableParams } from 'ng-table';\nngTableCoreModule.value('NgTableParams', ngTableParams_1.NgTableParams);\nvar ngTableDefaults_2 = __webpack_require__(7);\nexports.IDefaults = ngTableDefaults_2.IDefaults;\n__export(__webpack_require__(8));\nvar ngTableSettings_2 = __webpack_require__(10);\nexports.ISettings = ngTableSettings_2.ISettings;\n__export(__webpack_require__(9));\n__export(__webpack_require__(3));\n__export(__webpack_require__(36));\n__export(__webpack_require__(39));\n__export(__webpack_require__(40));\n__export(__webpack_require__(41));\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nvar angular = __webpack_require__(0);\nvar ngTable_directive_1 = __webpack_require__(13);\nvar ngTableColumn_1 = __webpack_require__(14);\nvar ngTableColumnsBinding_directive_1 = __webpack_require__(15);\nvar ngTableController_1 = __webpack_require__(16);\nexports.NgTableController = ngTableController_1.NgTableController;\nvar ngTableDynamic_directive_1 = __webpack_require__(17);\nvar ngTableFilterConfig_1 = __webpack_require__(18);\nexports.NgTableFilterConfigProvider = ngTableFilterConfig_1.NgTableFilterConfigProvider;\nexports.NgTableFilterConfig = ngTableFilterConfig_1.NgTableFilterConfig;\nvar ngTableFilterRow_directive_1 = __webpack_require__(19);\nvar ngTableFilterRowController_1 = __webpack_require__(20);\nvar ngTableGroupRow_directive_1 = __webpack_require__(21);\nvar ngTableGroupRowController_1 = __webpack_require__(22);\nvar ngTablePagination_directive_1 = __webpack_require__(23);\nvar ngTableSelectFilterDs_directive_1 = __webpack_require__(24);\nvar ngTableSorterRow_directive_1 = __webpack_require__(25);\nvar ngTableSorterRowController_1 = __webpack_require__(26);\n__webpack_require__(43);\n__webpack_require__(45);\n__webpack_require__(44);\n__webpack_require__(46);\n__webpack_require__(49);\n__webpack_require__(48);\nvar ngTableBrowserModule = angular.module('ngTable-browser', [])\n    .directive('ngTable', ngTable_directive_1.ngTable)\n    .service('ngTableColumn', ngTableColumn_1.NgTableColumn)\n    .directive('ngTableColumnsBinding', ngTableColumnsBinding_directive_1.ngTableColumnsBinding)\n    .controller('ngTableController', ngTableController_1.NgTableController)\n    .directive('ngTableDynamic', ngTableDynamic_directive_1.ngTableDynamic)\n    .provider('ngTableFilterConfig', ngTableFilterConfig_1.NgTableFilterConfigProvider)\n    .directive('ngTableFilterRow', ngTableFilterRow_directive_1.ngTableFilterRow)\n    .controller('ngTableFilterRowController', ngTableFilterRowController_1.NgTableFilterRowController)\n    .directive('ngTableGroupRow', ngTableGroupRow_directive_1.ngTableGroupRow)\n    .controller('ngTableGroupRowController', ngTableGroupRowController_1.NgTableGroupRowController)\n    .directive('ngTablePagination', ngTablePagination_directive_1.ngTablePagination)\n    .directive('ngTableSelectFilterDs', ngTableSelectFilterDs_directive_1.ngTableSelectFilterDs)\n    .directive('ngTableSorterRow', ngTableSorterRow_directive_1.ngTableSorterRow)\n    .controller('ngTableSorterRowController', ngTableSorterRowController_1.NgTableSorterRowController);\nexports.ngTableBrowserModule = ngTableBrowserModule;\n__export(__webpack_require__(27));\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n__export(__webpack_require__(28));\n__export(__webpack_require__(29));\n__export(__webpack_require__(30));\n__export(__webpack_require__(31));\n__export(__webpack_require__(32));\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\"use strict\";\n\"use strict\";\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\"use strict\";\n\"use strict\";\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\"use strict\";\n\"use strict\";\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\"use strict\";\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\"use strict\";\n/**\n * Default values for ngTable\n */\nexports.ngTableDefaults = {\n    params: {},\n    settings: {}\n};\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\"use strict\";\nvar ng1 = __webpack_require__(0);\nvar NgTableEventsChannel = (function () {\n    function NgTableEventsChannel($rootScope) {\n        this.$rootScope = $rootScope;\n        var events = this;\n        events = this.addTableParamsEvent('afterCreated', events);\n        events = this.addTableParamsEvent('afterReloadData', events);\n        events = this.addTableParamsEvent('datasetChanged', events);\n        events = this.addTableParamsEvent('pagesChanged', events);\n        events = this.addTableParamsEvent('afterDataFiltered', events);\n        events = this.addTableParamsEvent('afterDataSorted', events);\n    }\n    NgTableEventsChannel.prototype.addTableParamsEvent = function (eventName, target) {\n        var fnName = eventName.charAt(0).toUpperCase() + eventName.substring(1);\n        var event = (_a = {},\n            _a['on' + fnName] = this.createEventSubscriptionFn(eventName),\n            _a['publish' + fnName] = this.createPublishEventFn(eventName),\n            _a\n        );\n        return ng1.extend(target, event);\n        var _a;\n    };\n    NgTableEventsChannel.prototype.createPublishEventFn = function (eventName) {\n        var _this = this;\n        return function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i - 0] = arguments[_i];\n            }\n            (_a = _this.$rootScope).$broadcast.apply(_a, ['ngTable:' + eventName].concat(args));\n            var _a;\n        };\n    };\n    NgTableEventsChannel.prototype.createEventSubscriptionFn = function (eventName) {\n        var _this = this;\n        return function (handler, eventSelectorOrScope, eventSelector) {\n            var actualEvtSelector;\n            var scope = _this.$rootScope;\n            if (isScopeLike(eventSelectorOrScope)) {\n                scope = eventSelectorOrScope;\n                actualEvtSelector = createEventSelectorFn(eventSelector);\n            }\n            else {\n                actualEvtSelector = createEventSelectorFn(eventSelectorOrScope);\n            }\n            return scope.$on('ngTable:' + eventName, function (event, params) {\n                var eventArgs = [];\n                for (var _i = 2; _i < arguments.length; _i++) {\n                    eventArgs[_i - 2] = arguments[_i];\n                }\n                // don't send events published by the internal NgTableParams created by ngTableController\n                if (params.isNullInstance)\n                    return;\n                var fnArgs = [params].concat(eventArgs);\n                if (actualEvtSelector.apply(this, fnArgs)) {\n                    handler.apply(this, fnArgs);\n                }\n            });\n        };\n        function createEventSelectorFn(eventSelector) {\n            if (!eventSelector) {\n                return function (publisher) { return true; };\n            }\n            else if (isEventSelectorFunc(eventSelector)) {\n                return eventSelector;\n            }\n            else {\n                // shorthand for subscriber to only receive events from a specific publisher instance\n                return function (publisher) { return publisher === eventSelector; };\n            }\n        }\n        function isEventSelectorFunc(val) {\n            return typeof val === 'function';\n        }\n        function isScopeLike(val) {\n            return val && typeof val.$new === 'function';\n        }\n    };\n    NgTableEventsChannel.$inject = ['$rootScope'];\n    return NgTableEventsChannel;\n}());\nexports.NgTableEventsChannel = NgTableEventsChannel;\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\"use strict\";\nvar ng1 = __webpack_require__(0);\nvar util_1 = __webpack_require__(11);\n/**\n * @private\n */\nfunction isNumber(n) {\n    return !isNaN(parseFloat(n)) && isFinite(n);\n}\n/**\n * Parameters manager for an ngTable directive\n */\nvar NgTableParams = (function () {\n    function NgTableParams(baseParameters, baseSettings) {\n        var _this = this;\n        /**\n         * The page of data rows currently being displayed in the table\n         */\n        this.data = [];\n        this.defaultSettings = NgTableParams.ngTableSettings.createDefaults();\n        this.isCommittedDataset = false;\n        this.initialEvents = [];\n        this._params = {\n            page: 1,\n            count: 10,\n            filter: {},\n            sorting: {},\n            group: {}\n        };\n        this._settings = this.defaultSettings;\n        // the ngTableController \"needs\" to create a dummy/null instance and it's important to know whether an instance\n        // is one of these\n        if (typeof baseParameters === \"boolean\") {\n            this.isNullInstance = true;\n        }\n        this.reloadPages = (function () {\n            var currentPages;\n            return function () {\n                var oldPages = currentPages;\n                var newPages = _this.generatePagesArray(_this.page(), _this.total(), _this.count());\n                if (!ng1.equals(oldPages, newPages)) {\n                    currentPages = newPages;\n                    NgTableParams.ngTableEventsChannel.publishPagesChanged(_this, newPages, oldPages);\n                }\n            };\n        })();\n        ng1.extend(this._params, NgTableParams.ngTableDefaults.params);\n        this.settings(baseSettings);\n        this.parameters(baseParameters, true);\n        NgTableParams.ngTableEventsChannel.publishAfterCreated(this);\n        // run events during construction after the initial create event. That way a consumer\n        // can subscribe to all events for a table without \"dropping\" an event\n        ng1.forEach(this.initialEvents, function (event) {\n            event();\n        });\n        this.initialEvents = null;\n    }\n    NgTableParams.prototype.count = function (count) {\n        // reset to first page because can be blank page\n        return count !== undefined ? this.parameters({\n            'count': count,\n            'page': 1\n        }) : this._params.count;\n    };\n    NgTableParams.prototype.filter = function (filter) {\n        if (filter != null && typeof filter === 'object') {\n            return this.parameters({\n                'filter': filter,\n                'page': 1\n            });\n        }\n        else if (filter === true) {\n            var keys = Object.keys(this._params.filter);\n            var significantFilter = {};\n            for (var i = 0; i < keys.length; i++) {\n                var filterValue = this._params.filter[keys[i]];\n                if (filterValue != null && filterValue !== '') {\n                    significantFilter[keys[i]] = filterValue;\n                }\n            }\n            return significantFilter;\n        }\n        else {\n            return this._params.filter;\n        }\n    };\n    /**\n     * Generate array of pages.\n     * When no arguments supplied, the current parameter state of this `NgTableParams` instance will be used\n     * @param currentPage Which page must be active\n     * @param totalItems  Total quantity of items\n     * @param pageSize    Quantity of items on page\n     * @param maxBlocks   Quantity of blocks for pagination\n     * @returns Array of pages\n     */\n    NgTableParams.prototype.generatePagesArray = function (currentPage, totalItems, pageSize, maxBlocks) {\n        if (!arguments.length) {\n            currentPage = this.page();\n            totalItems = this.total();\n            pageSize = this.count();\n        }\n        var maxPage, maxPivotPages, minPage, numPages;\n        maxBlocks = maxBlocks && maxBlocks < 6 ? 6 : maxBlocks;\n        var pages = [];\n        numPages = Math.ceil(totalItems / pageSize);\n        if (numPages > 1) {\n            pages.push({\n                type: 'prev',\n                number: Math.max(1, currentPage - 1),\n                active: currentPage > 1\n            });\n            pages.push({\n                type: 'first',\n                number: 1,\n                active: currentPage > 1,\n                current: currentPage === 1\n            });\n            maxPivotPages = Math.round((this._settings.paginationMaxBlocks - this._settings.paginationMinBlocks) / 2);\n            minPage = Math.max(2, currentPage - maxPivotPages);\n            maxPage = Math.min(numPages - 1, currentPage + maxPivotPages * 2 - (currentPage - minPage));\n            minPage = Math.max(2, minPage - (maxPivotPages * 2 - (maxPage - minPage)));\n            var i = minPage;\n            while (i <= maxPage) {\n                if ((i === minPage && i !== 2) || (i === maxPage && i !== numPages - 1)) {\n                    pages.push({\n                        type: 'more',\n                        active: false\n                    });\n                }\n                else {\n                    pages.push({\n                        type: 'page',\n                        number: i,\n                        active: currentPage !== i,\n                        current: currentPage === i\n                    });\n                }\n                i++;\n            }\n            pages.push({\n                type: 'last',\n                number: numPages,\n                active: currentPage !== numPages,\n                current: currentPage === numPages\n            });\n            pages.push({\n                type: 'next',\n                number: Math.min(numPages, currentPage + 1),\n                active: currentPage < numPages\n            });\n        }\n        return pages;\n    };\n    NgTableParams.prototype.group = function (group, sortDirection) {\n        if (group === undefined) {\n            return this._params.group;\n        }\n        var newParameters = {\n            page: 1\n        };\n        if (util_1.isGroupingFun(group) && sortDirection !== undefined) {\n            group.sortDirection = sortDirection;\n            newParameters.group = group;\n        }\n        else if (typeof group === 'string' && sortDirection !== undefined) {\n            newParameters.group = (_a = {}, _a[group] = sortDirection, _a);\n        }\n        else {\n            newParameters.group = group;\n        }\n        this.parameters(newParameters);\n        return this;\n        var _a;\n    };\n    /**\n     * Returns true when an attempt to `reload` the current `parameter` values have resulted in a failure.\n     * This method will continue to return true until the `reload` is successfully called or when the\n     * `parameter` values have changed\n     */\n    NgTableParams.prototype.hasErrorState = function () {\n        return !!(this.errParamsMemento && ng1.equals(this.errParamsMemento, this.createComparableParams()));\n    };\n    /**\n     * Returns true if `filter` has significant filter value(s) (any value except null, undefined, or empty string),\n     * otherwise false\n     */\n    NgTableParams.prototype.hasFilter = function () {\n        return Object.keys(this.filter(true)).length > 0;\n    };\n    /**\n     * Return true when a change to `filters` require the `reload` method\n     * to be run so as to ensure the data presented to the user reflects these filters\n     */\n    NgTableParams.prototype.hasFilterChanges = function () {\n        var previousFilter = (this.prevParamsMemento && this.prevParamsMemento.params.filter);\n        return !ng1.equals((this._params.filter), previousFilter) || this.hasGlobalSearchFieldChanges();\n    };\n    NgTableParams.prototype.hasGroup = function (group, sortDirection) {\n        if (group == null) {\n            return util_1.isGroupingFun(this._params.group) || Object.keys(this._params.group).length > 0;\n        }\n        if (util_1.isGroupingFun(group)) {\n            if (sortDirection == null) {\n                return this._params.group === group;\n            }\n            else {\n                return this._params.group === group && group.sortDirection === sortDirection;\n            }\n        }\n        else {\n            if (sortDirection == null) {\n                return Object.keys(this._params.group).indexOf(group) !== -1;\n            }\n            else {\n                return this._params.group[group] === sortDirection;\n            }\n        }\n    };\n    /**\n     * Return true when a change to this instance should require the `reload` method\n     * to be run so as to ensure the data rows presented to the user reflects the current state.\n     *\n     * Note that this method will return false when the `reload` method has run but fails. In this case\n     * `hasErrorState` will return true.\n     *\n     * The built-in `ngTable` directives will watch for when this function returns true and will then call\n     * the `reload` method to load its data rows\n     */\n    NgTableParams.prototype.isDataReloadRequired = function () {\n        // note: using != as want to treat null and undefined the same\n        return !this.isCommittedDataset || !ng1.equals(this.createComparableParams(), this.prevParamsMemento)\n            || this.hasGlobalSearchFieldChanges();\n    };\n    /**\n     * Returns true if sorting by the field supplied. Where direction supplied\n     * the field must also be sorted by that direction to return true\n     */\n    NgTableParams.prototype.isSortBy = function (field, direction) {\n        if (direction !== undefined) {\n            return this._params.sorting[field] !== undefined && this._params.sorting[field] == direction;\n        }\n        else {\n            return this._params.sorting[field] !== undefined;\n        }\n    };\n    /**\n     * Returns sorting values in a format that can be consumed by the angular `$orderBy` filter service\n     */\n    NgTableParams.prototype.orderBy = function () {\n        return util_1.convertSortToOrderBy(this._params.sorting);\n    };\n    NgTableParams.prototype.page = function (page) {\n        return page !== undefined ? this.parameters({\n            'page': page\n        }) : this._params.page;\n    };\n    NgTableParams.prototype.parameters = function (newParameters, parseParamsFromUrl) {\n        parseParamsFromUrl = parseParamsFromUrl || false;\n        if (typeof newParameters !== undefined) {\n            for (var key in newParameters) {\n                var value = newParameters[key];\n                if (parseParamsFromUrl && key.indexOf('[') >= 0) {\n                    var keys = key.split(/\\[(.*)\\]/).reverse();\n                    var lastKey = '';\n                    for (var i = 0, len = keys.length; i < len; i++) {\n                        var name = keys[i];\n                        if (name !== '') {\n                            var v = value;\n                            value = {};\n                            value[lastKey = name] = (isNumber(v) ? parseFloat(v) : v);\n                        }\n                    }\n                    if (lastKey === 'sorting') {\n                        this._params[lastKey] = {};\n                    }\n                    this._params[lastKey] = ng1.extend(this._params[lastKey] || {}, value[lastKey]);\n                }\n                else {\n                    if (key === 'group') {\n                        this._params[key] = this.parseGroup(newParameters[key]);\n                    }\n                    else {\n                        this._params[key] = (isNumber(newParameters[key]) ? parseFloat(newParameters[key]) : newParameters[key]);\n                    }\n                }\n            }\n            this.log('ngTable: set parameters', this._params);\n            return this;\n        }\n        return this._params;\n    };\n    /**\n     * Trigger a reload of the data rows\n     */\n    NgTableParams.prototype.reload = function () {\n        var _this = this;\n        var pData = null;\n        this._settings.$loading = true;\n        this.prevParamsMemento = ng1.copy(this.createComparableParams());\n        this.isCommittedDataset = true;\n        if (this.hasGroup()) {\n            pData = this.runInterceptorPipeline(NgTableParams.$q.when(this._settings.getGroups(this)));\n        }\n        else {\n            var fn = this._settings.getData;\n            pData = this.runInterceptorPipeline(NgTableParams.$q.when(fn(this)));\n        }\n        this.log('ngTable: reload data');\n        var oldData = this.data;\n        return pData.then(function (data) {\n            _this._settings.$loading = false;\n            _this.errParamsMemento = null;\n            _this.data = data;\n            // note: I think it makes sense to publish this event even when data === oldData\n            // subscribers can always set a filter to only receive the event when data !== oldData\n            NgTableParams.ngTableEventsChannel.publishAfterReloadData(_this, data, oldData);\n            _this.reloadPages();\n            return data;\n        }).catch(function (reason) {\n            _this.errParamsMemento = _this.prevParamsMemento;\n            // \"rethrow\"\n            return NgTableParams.$q.reject(reason);\n        });\n    };\n    NgTableParams.prototype.settings = function (newSettings) {\n        var _this = this;\n        if (ng1.isDefined(newSettings)) {\n            var settings = NgTableParams.ngTableSettings.merge(this._settings, newSettings);\n            var originalDataset_1 = this._settings.dataset;\n            this._settings = settings;\n            // note: using != as want null and undefined to be treated the same\n            var hasDatasetChanged = newSettings.hasOwnProperty('dataset') && (newSettings.dataset != originalDataset_1);\n            if (hasDatasetChanged) {\n                if (this.isCommittedDataset) {\n                    this.page(1); // reset page as a new dataset has been supplied\n                }\n                this.isCommittedDataset = false;\n                var fireEvent = function () {\n                    NgTableParams.ngTableEventsChannel.publishDatasetChanged(_this, newSettings.dataset, originalDataset_1);\n                };\n                if (this.initialEvents) {\n                    this.initialEvents.push(fireEvent);\n                }\n                else {\n                    fireEvent();\n                }\n            }\n            this.log('ngTable: set settings', this._settings);\n            return this;\n        }\n        return this._settings;\n    };\n    NgTableParams.prototype.sorting = function (sorting, direction) {\n        if (typeof sorting === 'string') {\n            this.parameters({\n                'sorting': (_a = {}, _a[sorting] = direction, _a)\n            });\n            return this;\n        }\n        return sorting !== undefined ? this.parameters({\n            'sorting': sorting\n        }) : this._params.sorting;\n        var _a;\n    };\n    NgTableParams.prototype.total = function (total) {\n        return total !== undefined ? this.settings({\n            'total': total\n        }) : this._settings.total;\n    };\n    /**\n     * Returns the current parameter values uri-encoded. Set `asString` to\n     * true for the parameters to be returned as an array of strings of the form 'paramName=value'\n     * otherwise parameters returned as a key-value object\n     */\n    NgTableParams.prototype.url = function (asString) {\n        // this function is an example of Typescript gone bad!!\n        asString = asString || false;\n        var pairs = (asString ? [] : {});\n        for (var key in this._params) {\n            if (this._params.hasOwnProperty(key)) {\n                var item = this._params[key], name = encodeURIComponent(key);\n                if (typeof item === \"object\") {\n                    for (var subkey in item) {\n                        if (isSignificantValue(item[subkey], key)) {\n                            var pname = name + \"[\" + encodeURIComponent(subkey) + \"]\";\n                            collectValue(item[subkey], pname);\n                        }\n                    }\n                }\n                else if (!ng1.isFunction(item) && isSignificantValue(item, key)) {\n                    collectValue(item, name);\n                }\n            }\n        }\n        return pairs;\n        function collectValue(value, key) {\n            if (isArray(pairs)) {\n                pairs.push(key + \"=\" + encodeURIComponent(value));\n            }\n            else {\n                pairs[key] = encodeURIComponent(value);\n            }\n        }\n        function isArray(pairs) {\n            return asString;\n        }\n        function isSignificantValue(value, key) {\n            return key === \"group\" ? true : typeof value !== undefined && value !== \"\";\n        }\n    };\n    NgTableParams.prototype.createComparableParams = function () {\n        var group = this._params.group;\n        return {\n            params: this._params,\n            groupSortDirection: util_1.isGroupingFun(group) ? group.sortDirection : undefined\n        };\n    };\n    NgTableParams.prototype.hasGlobalSearchFieldChanges = function () {\n        var currentVal = (this._params.filter && this._params.filter['$']);\n        var previousVal = (this.prevParamsMemento && this.prevParamsMemento.params.filter && this.prevParamsMemento.params.filter['$']);\n        return !ng1.equals(currentVal, previousVal);\n    };\n    NgTableParams.prototype.log = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i - 0] = arguments[_i];\n        }\n        if (this._settings.debugMode && NgTableParams.$log.debug) {\n            (_a = NgTableParams.$log).debug.apply(_a, args);\n        }\n        var _a;\n    };\n    NgTableParams.prototype.parseGroup = function (group) {\n        var defaultSort = this._settings.groupOptions && this._settings.groupOptions.defaultSort;\n        if (!group) {\n            return group;\n        }\n        else if (util_1.isGroupingFun(group)) {\n            if (group.sortDirection == null) {\n                group.sortDirection = defaultSort;\n            }\n            return group;\n        }\n        else if (typeof group === 'object') {\n            for (var key in group) {\n                if (group[key] == null) {\n                    group[key] = defaultSort;\n                }\n            }\n            return group;\n        }\n        else {\n            return (_a = {},\n                _a[group] = defaultSort,\n                _a\n            );\n        }\n        var _a;\n    };\n    NgTableParams.prototype.runInterceptorPipeline = function (fetchedData) {\n        var _this = this;\n        var interceptors = this._settings.interceptors || [];\n        return interceptors.reduce(function (result, interceptor) {\n            var thenFn = (interceptor.response && interceptor.response.bind(interceptor)) || NgTableParams.$q.when;\n            var rejectFn = (interceptor.responseError && interceptor.responseError.bind(interceptor)) || NgTableParams.$q.reject;\n            return result.then(function (data) {\n                return thenFn(data, _this);\n            }, function (reason) {\n                return rejectFn(reason, _this);\n            });\n        }, fetchedData);\n    };\n    NgTableParams.init = function ($q, $log, ngTableDefaults, ngTableEventsChannel, ngTableSettings) {\n        NgTableParams.$q = $q;\n        NgTableParams.$log = $log;\n        NgTableParams.ngTableDefaults = ngTableDefaults;\n        NgTableParams.ngTableEventsChannel = ngTableEventsChannel;\n        NgTableParams.ngTableSettings = ngTableSettings;\n    };\n    return NgTableParams;\n}());\nexports.NgTableParams = NgTableParams;\nNgTableParams.init.$inject = ['$q', '$log', 'ngTableDefaults', 'ngTableEventsChannel', 'ngTableSettings'];\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\"use strict\";\nvar ng1 = __webpack_require__(0);\n/**\n * @private\n */\nvar NgTableSettings = (function () {\n    function NgTableSettings(ngTableDefaults, ngTableDefaultGetData, ngTableDefaultGetGroups) {\n        var _this = this;\n        this.ngTableDefaults = ngTableDefaults;\n        this.ngTableDefaultGetData = ngTableDefaultGetData;\n        this.ngTableDefaultGetGroups = ngTableDefaultGetGroups;\n        this.defaults = {\n            $loading: false,\n            dataset: null,\n            total: 0,\n            defaultSort: 'desc',\n            counts: [10, 25, 50, 100],\n            filterOptions: {\n                filterComparator: undefined,\n                filterDelay: 500,\n                filterDelayThreshold: 10000,\n                filterFilterName: undefined,\n                filterFn: undefined,\n                filterLayout: 'stack'\n            },\n            getData: function (params) {\n                return _this.ngTableDefaultGetData(params.settings().dataset, params);\n            },\n            getGroups: this.ngTableDefaultGetGroups,\n            groupOptions: {\n                defaultSort: 'asc',\n                isExpanded: true\n            },\n            interceptors: [],\n            paginationMaxBlocks: 11,\n            paginationMinBlocks: 5,\n            sortingIndicator: 'span'\n        };\n    }\n    NgTableSettings.prototype.createDefaults = function () {\n        return this.merge(this.defaults, this.ngTableDefaults.settings);\n    };\n    NgTableSettings.prototype.merge = function (existing, newSettings) {\n        newSettings = ng1.extend({}, newSettings);\n        if (newSettings.filterOptions) {\n            newSettings.filterOptions = ng1.extend({}, existing.filterOptions || {}, newSettings.filterOptions);\n        }\n        if (newSettings.groupOptions) {\n            newSettings.groupOptions = ng1.extend({}, existing.groupOptions || {}, newSettings.groupOptions);\n        }\n        if (ng1.isArray(newSettings.dataset)) {\n            //auto-set the total from passed in dataset\n            newSettings.total = newSettings.dataset.length;\n        }\n        var results = ng1.extend({}, existing, newSettings);\n        if (ng1.isArray(newSettings.dataset)) {\n            this.optimizeFilterDelay(results);\n        }\n        return ng1.extend({}, existing, newSettings);\n    };\n    NgTableSettings.prototype.optimizeFilterDelay = function (settings) {\n        // don't debounce by default filter input when working with small synchronous datasets\n        if (settings.filterOptions.filterDelay === this.defaults.filterOptions.filterDelay &&\n            settings.total <= settings.filterOptions.filterDelayThreshold &&\n            settings.getData === this.defaults.getData) {\n            settings.filterOptions.filterDelay = 0;\n        }\n    };\n    NgTableSettings.$inject = ['ngTableDefaults', 'ngTableDefaultGetData', 'ngTableDefaultGetGroups'];\n    return NgTableSettings;\n}());\nexports.NgTableSettings = NgTableSettings;\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\"use strict\";\n\"use strict\";\n/**\n * @private\n */\nfunction convertSortToOrderBy(sorting) {\n    var result = [];\n    for (var column in sorting) {\n        result.push((sorting[column] === \"asc\" ? \"+\" : \"-\") + column);\n    }\n    return result;\n}\nexports.convertSortToOrderBy = convertSortToOrderBy;\n/**\n * @private\n */\nfunction isGroupingFun(val) {\n    return typeof val === 'function';\n}\nexports.isGroupingFun = isGroupingFun;\n\n\n/***/ },\n/* 12 */,\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\"use strict\";\nvar ng1 = __webpack_require__(0);\nngTable.$inject = ['$q', '$parse'];\n/**\n * Directive that instantiates {@link NgTableController NgTableController}.\n * @ngdoc directive\n * @name ngTable\n * @example\n *\n * ```html\n * <table ng-table=\"$ctrl.tableParams\" show-filter=\"true\" class=\"table table-bordered\">\n *  <tr ng-repeat=\"user in $data\">\n *      <td data-title=\"'Name'\" sortable=\"'name'\" filter=\"{ 'name': 'text' }\">\n *          {{user.name}}\n *      </td>\n *      <td data-title=\"'Age'\" sortable=\"'age'\" filter=\"{ 'age': 'text' }\">\n *          {{user.age}}\n *      </td>\n *  </tr>\n * </table>\n * ```\n */\nfunction ngTable($q, $parse) {\n    return {\n        restrict: 'A',\n        priority: 1001,\n        scope: true,\n        controller: 'ngTableController',\n        compile: function (element) {\n            var columns = [], i = 0, dataRow, groupRow;\n            var rows = [];\n            ng1.forEach(element.find('tr'), function (tr) {\n                rows.push(ng1.element(tr));\n            });\n            dataRow = rows.filter(function (tr) { return !tr.hasClass('ng-table-group'); })[0];\n            groupRow = rows.filter(function (tr) { return tr.hasClass('ng-table-group'); })[0];\n            if (!dataRow) {\n                return undefined;\n            }\n            ng1.forEach(dataRow.find('td'), function (item) {\n                var el = ng1.element(item);\n                if (el.attr('ignore-cell') && 'true' === el.attr('ignore-cell')) {\n                    return;\n                }\n                var getAttrValue = function (attr) {\n                    return el.attr('x-data-' + attr) || el.attr('data-' + attr) || el.attr(attr);\n                };\n                var setAttrValue = function (attr, value) {\n                    if (el.attr('x-data-' + attr)) {\n                        el.attr('x-data-' + attr, value);\n                    }\n                    else if (el.attr('data' + attr)) {\n                        el.attr('data' + attr, value);\n                    }\n                    else {\n                        el.attr(attr, value);\n                    }\n                };\n                var parsedAttribute = function (attr) {\n                    var expr = getAttrValue(attr);\n                    if (!expr) {\n                        return undefined;\n                    }\n                    var localValue;\n                    var getter = function (context) {\n                        if (localValue !== undefined) {\n                            return localValue;\n                        }\n                        return $parse(expr)(context);\n                    };\n                    getter.assign = function ($scope, value) {\n                        var parsedExpr = $parse(expr);\n                        if (parsedExpr.assign) {\n                            // we should be writing back to the parent scope as this is where the expression\n                            // came from\n                            parsedExpr.assign($scope.$parent, value);\n                        }\n                        else {\n                            localValue = value;\n                        }\n                    };\n                    return getter;\n                };\n                var titleExpr = getAttrValue('title-alt') || getAttrValue('title');\n                if (titleExpr) {\n                    el.attr('data-title-text', '{{' + titleExpr + '}}'); // this used in responsive table\n                }\n                // NOTE TO MAINTAINERS: if you add extra fields to a $column be sure to extend ngTableColumn with\n                // a corresponding \"safe\" default\n                columns.push({\n                    id: i++,\n                    title: parsedAttribute('title'),\n                    titleAlt: parsedAttribute('title-alt'),\n                    headerTitle: parsedAttribute('header-title'),\n                    sortable: parsedAttribute('sortable'),\n                    'class': parsedAttribute('header-class'),\n                    filter: parsedAttribute('filter'),\n                    groupable: parsedAttribute('groupable'),\n                    headerTemplateURL: parsedAttribute('header'),\n                    filterData: parsedAttribute('filter-data'),\n                    show: el.attr(\"ng-if\") ? parsedAttribute('ng-if') : undefined\n                });\n                if (groupRow || el.attr(\"ng-if\")) {\n                    // change ng-if to bind to our column definition which we know will be writable\n                    // because this will potentially increase the $watch count, only do so if we already have an\n                    // ng-if or when we definitely need to change visibility of the columns.\n                    // currently only ngTableGroupRow directive needs to change visibility\n                    setAttrValue('ng-if', '$columns[' + (columns.length - 1) + '].show(this)');\n                }\n            });\n            return function (scope, element, attrs, controller) {\n                scope.$columns = columns = controller.buildColumns(columns);\n                controller.setupBindingsToInternalScope(attrs.ngTable);\n                controller.loadFilterData(columns);\n                controller.compileDirectiveTemplates();\n            };\n        }\n    };\n}\nexports.ngTable = ngTable;\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\"use strict\";\nvar ng1 = __webpack_require__(0);\n/**\n * @private\n */\nfunction isScopeLike(object) {\n    return object != null && ng1.isFunction(object.$new);\n}\n/**\n * @private\n * Service to construct a $column definition used by {@link ngTable ngTable} directive\n */\nvar NgTableColumn = (function () {\n    function NgTableColumn() {\n    }\n    /**\n     * Creates a $column for use within a header template\n     *\n     * @param column the initial definition for $column to build\n     * @param defaultScope the $scope to supply to the $column getter methods when not supplied by caller\n     * @param columns a reference to the $columns array to make available on the context supplied to the\n     * $column getter methods\n     */\n    NgTableColumn.prototype.buildColumn = function (column, defaultScope, columns) {\n        // note: we're not modifying the original column object. This helps to avoid unintended side affects\n        var extendedCol = Object.create(column);\n        var defaults = this.createDefaults();\n        var _loop_1 = function(prop) {\n            if (extendedCol[prop] === undefined) {\n                extendedCol[prop] = defaults[prop];\n            }\n            if (!ng1.isFunction(extendedCol[prop])) {\n                // wrap raw field values with \"getter\" functions\n                // - this is to ensure consistency with how ngTable.compile builds columns\n                // - note that the original column object is being \"proxied\"; this is important\n                //   as it ensure that any changes to the original object will be returned by the \"getter\"\n                var getterSetter = function getterSetter() {\n                    if (arguments.length === 1 && !isScopeLike(arguments[0])) {\n                        getterSetter.assign(null, arguments[0]);\n                    }\n                    else {\n                        return column[prop];\n                    }\n                };\n                getterSetter.assign = function ($scope, value) {\n                    column[prop] = value;\n                };\n                extendedCol[prop] = getterSetter;\n            }\n            // satisfy the arguments expected by the function returned by parsedAttribute in the ngTable directive\n            var getterFn = extendedCol[prop];\n            extendedCol[prop] = function () {\n                if (arguments.length === 1 && !isScopeLike(arguments[0])) {\n                    getterFn.assign(defaultScope, arguments[0]);\n                }\n                else {\n                    var scope = arguments[0] || defaultScope;\n                    var context = Object.create(scope);\n                    ng1.extend(context, {\n                        $column: extendedCol,\n                        $columns: columns\n                    });\n                    return getterFn.call(column, context);\n                }\n            };\n            if (getterFn.assign) {\n                extendedCol[prop].assign = getterFn.assign;\n            }\n            else {\n                var wrappedGetterFn_1 = extendedCol[prop];\n                var localValue_1;\n                var getterSetter = function getterSetter() {\n                    if (arguments.length === 1 && !isScopeLike(arguments[0])) {\n                        getterSetter.assign(null, arguments[0]);\n                    }\n                    else {\n                        return localValue_1 != undefined ? localValue_1 : wrappedGetterFn_1.apply(extendedCol, arguments);\n                    }\n                };\n                getterSetter.assign = function ($scope, value) {\n                    localValue_1 = value;\n                };\n                extendedCol[prop] = getterSetter;\n            }\n        };\n        for (var prop in defaults) {\n            _loop_1(prop);\n        }\n        return extendedCol;\n    };\n    NgTableColumn.prototype.createDefaults = function () {\n        return {\n            'class': this.createGetterSetter(''),\n            filter: this.createGetterSetter(false),\n            groupable: this.createGetterSetter(false),\n            filterData: ng1.noop,\n            headerTemplateURL: this.createGetterSetter(false),\n            headerTitle: this.createGetterSetter(''),\n            sortable: this.createGetterSetter(false),\n            show: this.createGetterSetter(true),\n            title: this.createGetterSetter(''),\n            titleAlt: this.createGetterSetter('')\n        };\n    };\n    NgTableColumn.prototype.createGetterSetter = function (initialValue) {\n        var value = initialValue;\n        var getterSetter = function getterSetter() {\n            if (arguments.length === 1 && !isScopeLike(arguments[0])) {\n                getterSetter.assign(null, arguments[0]);\n            }\n            else {\n                return value;\n            }\n        };\n        getterSetter.assign = function ($scope, newValue) {\n            value = newValue;\n        };\n        return getterSetter;\n    };\n    NgTableColumn.$inject = [];\n    return NgTableColumn;\n}());\nexports.NgTableColumn = NgTableColumn;\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports) {\n\n\"use strict\";\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\"use strict\";\nngTableColumnsBinding.$inject = [\"$parse\"];\n/**\n * One-way data binds the $columns array generated by ngTable/ngTableDynamic to the specified\n * expression.\n * This allows the $columns array created for the table to be accessed outside of the html table\n * markup.\n *\n * @ngdoc directive\n *\n * @example\n * ```html\n * <table ng-table=\"$ctrl.tableParams\" class=\"table\" ng-table-columns-binding=\"$ctlr.tableColumns\">\n * ```\n */\nfunction ngTableColumnsBinding($parse) {\n    var directive = {\n        restrict: 'A',\n        link: linkFn\n    };\n    return directive;\n    function linkFn($scope, $element, $attrs) {\n        var setter = $parse($attrs.ngTableColumnsBinding).assign;\n        if (setter) {\n            $scope.$watch('$columns', function (newColumns) {\n                var shallowClone = (newColumns || []).slice(0);\n                setter($scope, shallowClone);\n            });\n        }\n    }\n}\nexports.ngTableColumnsBinding = ngTableColumnsBinding;\n\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\"use strict\";\nvar ng1 = __webpack_require__(0);\nvar core_1 = __webpack_require__(1);\n/**\n * The controller for the {@link ngTable ngTable} and {@link ngTableDynamic ngTableDynamic} directives\n */\nvar NgTableController = (function () {\n    function NgTableController($scope, $timeout, $parse, $compile, $attrs, $element, $document, ngTableColumn, ngTableEventsChannel) {\n        this.$scope = $scope;\n        this.$parse = $parse;\n        this.$compile = $compile;\n        this.$attrs = $attrs;\n        this.$element = $element;\n        this.$document = $document;\n        this.ngTableColumn = ngTableColumn;\n        this.ngTableEventsChannel = ngTableEventsChannel;\n        var isFirstTimeLoad = true;\n        $scope.$filterRow = { disabled: false };\n        $scope.$loading = false;\n        // until such times as the directive uses an isolated scope, we need to ensure that the check for\n        // the params field only consults the \"own properties\" of the $scope. This is to avoid seeing the params\n        // field on a $scope higher up in the prototype chain\n        if (!$scope.hasOwnProperty(\"params\")) {\n            $scope.params = new core_1.NgTableParams(true);\n        }\n        this.delayFilter = (function () {\n            var timer;\n            return function (callback, ms) {\n                $timeout.cancel(timer);\n                timer = $timeout(callback, ms);\n            };\n        })();\n        // watch for when a new NgTableParams is bound to the scope\n        // CRITICAL: the watch must be for reference and NOT value equality; this is because NgTableParams maintains\n        // the current data page as a field. Checking this for value equality would be terrible for performance\n        // and potentially cause an error if the items in that array has circular references\n        this.$scope.$watch('params', function (newParams, oldParams) {\n            if (newParams === oldParams || !newParams) {\n                return;\n            }\n            newParams.reload();\n        }, false);\n        this.subscribeToTableEvents();\n    }\n    Object.defineProperty(NgTableController.prototype, \"hasVisibleFilterColumn\", {\n        get: function () {\n            var _this = this;\n            if (!this.$scope.$columns)\n                return false;\n            return this.some(this.$scope.$columns, function ($column) {\n                return $column.show(_this.$scope) && !!$column.filter(_this.$scope);\n            });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    NgTableController.prototype.onDataReloadStatusChange = function (newStatus /*, oldStatus*/) {\n        if (!newStatus || this.$scope.params.hasErrorState()) {\n            return;\n        }\n        var currentParams = this.$scope.params;\n        var filterOptions = currentParams.settings().filterOptions;\n        if (currentParams.hasFilterChanges()) {\n            var applyFilter = function () {\n                currentParams.page(1);\n                currentParams.reload();\n            };\n            if (filterOptions.filterDelay) {\n                this.delayFilter(applyFilter, filterOptions.filterDelay);\n            }\n            else {\n                applyFilter();\n            }\n        }\n        else {\n            currentParams.reload();\n        }\n    };\n    NgTableController.prototype.compileDirectiveTemplates = function () {\n        if (!this.$element.hasClass('ng-table')) {\n            this.$scope.templates = {\n                header: (this.$attrs.templateHeader ? this.$attrs.templateHeader : 'ng-table/header.html'),\n                pagination: (this.$attrs.templatePagination ? this.$attrs.templatePagination : 'ng-table/pager.html')\n            };\n            this.$element.addClass('ng-table');\n            var headerTemplate = null;\n            // $element.find('> thead').length === 0 doesn't work on jqlite\n            var theadFound_1 = false;\n            ng1.forEach(this.$element.children(), function (e) {\n                if (e.tagName === 'THEAD') {\n                    theadFound_1 = true;\n                }\n            });\n            if (!theadFound_1) {\n                headerTemplate = ng1.element('<thead ng-include=\"templates.header\"></thead>', this.$document);\n                this.$element.prepend(headerTemplate);\n            }\n            var paginationTemplate = ng1.element('<div ng-table-pagination=\"params\" template-url=\"templates.pagination\"></div>', this.$document);\n            this.$element.after(paginationTemplate);\n            if (headerTemplate) {\n                this.$compile(headerTemplate)(this.$scope);\n            }\n            this.$compile(paginationTemplate)(this.$scope);\n        }\n    };\n    NgTableController.prototype.loadFilterData = function ($columns) {\n        var _this = this;\n        ng1.forEach($columns, function ($column) {\n            var result = $column.filterData(_this.$scope);\n            if (!result) {\n                delete $column.filterData;\n                return undefined;\n            }\n            if (isPromiseLike(result)) {\n                delete $column.filterData;\n                return result.then(function (data) {\n                    // our deferred can eventually return arrays, functions and objects\n                    if (!ng1.isArray(data) && !ng1.isFunction(data) && !ng1.isObject(data)) {\n                        // if none of the above was found - we just want an empty array\n                        data = [];\n                    }\n                    $column.data = data;\n                });\n            }\n            else {\n                return $column.data = result;\n            }\n        });\n        function isPromiseLike(val) {\n            return val && typeof val === 'object' && typeof val.then === 'function';\n        }\n    };\n    NgTableController.prototype.buildColumns = function (columns) {\n        var _this = this;\n        // todo: use strictNullChecks and remove guard clause\n        var result = [];\n        (columns || []).forEach(function (col) {\n            result.push(_this.ngTableColumn.buildColumn(col, _this.$scope, result));\n        });\n        return result;\n    };\n    NgTableController.prototype.parseNgTableDynamicExpr = function (attr) {\n        if (!attr || attr.indexOf(\" with \") > -1) {\n            var parts = attr.split(/\\s+with\\s+/);\n            return {\n                tableParams: parts[0],\n                columns: parts[1]\n            };\n        }\n        else {\n            throw new Error('Parse error (expected example: ng-table-dynamic=\\'tableParams with cols\\')');\n        }\n    };\n    NgTableController.prototype.setupBindingsToInternalScope = function (tableParamsExpr) {\n        // note: this we're setting up watches to simulate angular's isolated scope bindings\n        var _this = this;\n        // note: is REALLY important to watch for a change to the ngTableParams *reference* rather than\n        // $watch for value equivalence. This is because ngTableParams references the current page of data as\n        // a field and it's important not to watch this\n        this.$scope.$watch(tableParamsExpr, function (params) {\n            if (params === undefined) {\n                return;\n            }\n            _this.$scope.params = params;\n        }, false);\n        this.setupFilterRowBindingsToInternalScope();\n        this.setupGroupRowBindingsToInternalScope();\n    };\n    NgTableController.prototype.setupFilterRowBindingsToInternalScope = function () {\n        var _this = this;\n        if (this.$attrs.showFilter) {\n            this.$scope.$parent.$watch(this.$attrs.showFilter, function (value) {\n                _this.$scope.show_filter = value;\n            });\n        }\n        else {\n            this.$scope.$watch(function () { return _this.hasVisibleFilterColumn; }, function (value) {\n                _this.$scope.show_filter = value;\n            });\n        }\n        if (this.$attrs.disableFilter) {\n            this.$scope.$parent.$watch(this.$attrs.disableFilter, function (value) {\n                _this.$scope.$filterRow.disabled = value;\n            });\n        }\n    };\n    NgTableController.prototype.setupGroupRowBindingsToInternalScope = function () {\n        var _this = this;\n        this.$scope.$groupRow = { show: false };\n        if (this.$attrs.showGroup) {\n            var showGroupGetter_1 = this.$parse(this.$attrs.showGroup);\n            this.$scope.$parent.$watch(showGroupGetter_1, function (value) {\n                _this.$scope.$groupRow.show = value;\n            });\n            if (showGroupGetter_1.assign) {\n                // setup two-way databinding thus allowing ngTableGrowRow to assign to the showGroup expression\n                this.$scope.$watch('$groupRow.show', function (value) {\n                    showGroupGetter_1.assign(_this.$scope.$parent, value);\n                });\n            }\n        }\n        else {\n            this.$scope.$watch('params.hasGroup()', function (newValue) {\n                _this.$scope.$groupRow.show = newValue;\n            });\n        }\n    };\n    NgTableController.prototype.getVisibleColumns = function () {\n        var _this = this;\n        return (this.$scope.$columns || []).filter(function (c) {\n            return c.show(_this.$scope);\n        });\n    };\n    NgTableController.prototype.subscribeToTableEvents = function () {\n        var _this = this;\n        this.$scope.$watch('params.isDataReloadRequired()', function (newStatus /*, oldStatus*/) {\n            _this.onDataReloadStatusChange(newStatus);\n        });\n        this.ngTableEventsChannel.onAfterReloadData(function (params, newDatapage) {\n            var visibleColumns = _this.getVisibleColumns();\n            if (params.hasGroup()) {\n                _this.$scope.$groups = (newDatapage || []);\n                _this.$scope.$groups.visibleColumnCount = visibleColumns.length;\n            }\n            else {\n                _this.$scope.$data = (newDatapage || []);\n                _this.$scope.$data.visibleColumnCount = visibleColumns.length;\n            }\n        }, this.$scope, function (publisher) { return _this.$scope.params === publisher; });\n        this.ngTableEventsChannel.onPagesChanged(function (params, newPages) {\n            _this.$scope.pages = newPages;\n        }, this.$scope, function (publisher) { return _this.$scope.params === publisher; });\n    };\n    NgTableController.prototype.some = function (array, predicate) {\n        var found = false;\n        for (var i = 0; i < array.length; i++) {\n            var obj = array[i];\n            if (predicate(obj)) {\n                found = true;\n                break;\n            }\n        }\n        return found;\n    };\n    NgTableController.$inject = [\n        '$scope', '$timeout', '$parse', '$compile', '$attrs', '$element', '$document', 'ngTableColumn', 'ngTableEventsChannel'\n    ];\n    return NgTableController;\n}());\nexports.NgTableController = NgTableController;\n\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\"use strict\";\nvar ng1 = __webpack_require__(0);\nngTableDynamic.$inject = [];\n/**\n * A dynamic version of the {@link ngTable ngTable} directive that accepts a dynamic list of columns\n * definitions to render\n * @ngdoc directive\n *\n * @example\n * ```html\n * <table ng-table-dynamic=\"$ctrl.tableParams with $ctrl.cols\" class=\"table\">\n *  <tr ng-repeat=\"row in $data\">\n *    <td ng-repeat=\"col in $columns\">{{row[col.field]}}</td>\n *  </tr>\n * </table>\n * ```\n */\nfunction ngTableDynamic() {\n    return {\n        restrict: 'A',\n        priority: 1001,\n        scope: true,\n        controller: 'ngTableController',\n        compile: function (tElement) {\n            var row;\n            // IE 8 fix :not(.ng-table-group) selector\n            ng1.forEach(tElement.find('tr'), function (tr) {\n                tr = ng1.element(tr);\n                if (!tr.hasClass('ng-table-group') && !row) {\n                    row = tr;\n                }\n            });\n            if (!row) {\n                return undefined;\n            }\n            ng1.forEach(row.find('td'), function (item) {\n                var el = ng1.element(item);\n                var getAttrValue = function (attr) {\n                    return el.attr('x-data-' + attr) || el.attr('data-' + attr) || el.attr(attr);\n                };\n                // this used in responsive table\n                var titleExpr = getAttrValue('title');\n                if (!titleExpr) {\n                    el.attr('data-title-text', '{{$columns[$index].titleAlt(this) || $columns[$index].title(this)}}');\n                }\n                var showExpr = el.attr('ng-if');\n                if (!showExpr) {\n                    el.attr('ng-if', '$columns[$index].show(this)');\n                }\n            });\n            return function (scope, element, attrs, controller) {\n                var expr = controller.parseNgTableDynamicExpr(attrs.ngTableDynamic);\n                controller.setupBindingsToInternalScope(expr.tableParams);\n                controller.compileDirectiveTemplates();\n                scope.$watchCollection(expr.columns, function (newCols /*, oldCols*/) {\n                    scope.$columns = controller.buildColumns(newCols);\n                    controller.loadFilterData(scope.$columns);\n                });\n            };\n        }\n    };\n}\nexports.ngTableDynamic = ngTableDynamic;\n\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\"use strict\";\nvar ng1 = __webpack_require__(0);\n/**\n * The angular provider used to configure the behaviour of the `NgTableFilterConfig` service.\n */\nvar NgTableFilterConfigProvider = (function () {\n    function NgTableFilterConfigProvider($injector) {\n        var _this = this;\n        this.defaultConfig = {\n            defaultBaseUrl: 'ng-table/filters/',\n            defaultExt: '.html',\n            aliasUrls: {}\n        };\n        this.$get = function () {\n            return $injector.instantiate(NgTableFilterConfig, { config: ng1.copy(_this.config) });\n        };\n        this.$get.$inject = [];\n        this.resetConfigs();\n    }\n    /**\n     * Reset back to factory defaults the config values that `NgTableFilterConfig` service will use\n     */\n    NgTableFilterConfigProvider.prototype.resetConfigs = function () {\n        this.config = this.defaultConfig;\n    };\n    /**\n     * Set the config values used by `NgTableFilterConfig` service\n     */\n    NgTableFilterConfigProvider.prototype.setConfig = function (customConfig) {\n        var mergeConfig = ng1.extend({}, this.config, customConfig);\n        mergeConfig.aliasUrls = ng1.extend({}, this.config.aliasUrls, customConfig.aliasUrls);\n        this.config = mergeConfig;\n    };\n    NgTableFilterConfigProvider.$inject = ['$injector'];\n    return NgTableFilterConfigProvider;\n}());\nexports.NgTableFilterConfigProvider = NgTableFilterConfigProvider;\n/**\n * Exposes configuration values and methods used to return the location of the html\n * templates used to render the filter row of an ng-table directive\n */\nvar NgTableFilterConfig = (function () {\n    function NgTableFilterConfig(\n        /**\n         * Readonly copy of the final values used to configure the service.\n         */\n        config) {\n        this.config = config;\n    }\n    /**\n     * Return the url of the html filter template registered with the alias supplied\n     */\n    NgTableFilterConfig.prototype.getUrlForAlias = function (aliasName, filterKey) {\n        return this.config.aliasUrls[aliasName] || this.config.defaultBaseUrl + aliasName + this.config.defaultExt;\n    };\n    /**\n     * Return the url of the html filter template for the supplied definition and key.\n     * For more information see the documentation for {@link IFilterTemplateMap}\n     */\n    NgTableFilterConfig.prototype.getTemplateUrl = function (filterDef, filterKey) {\n        var filterName;\n        if (typeof filterDef !== 'string') {\n            filterName = filterDef.id;\n        }\n        else {\n            filterName = filterDef;\n        }\n        if (filterName.indexOf('/') !== -1) {\n            return filterName;\n        }\n        return this.getUrlForAlias(filterName, filterKey);\n    };\n    NgTableFilterConfig.$inject = ['config'];\n    return NgTableFilterConfig;\n}());\nexports.NgTableFilterConfig = NgTableFilterConfig;\n\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\"use strict\";\nvar templateUrl = __webpack_require__(42);\nngTableFilterRow.$inject = [];\n/**\n * directive that renders the filter header row for a table\n * @ngdoc directive\n * @example\n * ```html\n * <ng-table-filter-row></ng-table-filter-row>\n * ```\n */\nfunction ngTableFilterRow() {\n    var directive = {\n        restrict: 'E',\n        replace: true,\n        templateUrl: templateUrl,\n        scope: true,\n        controller: 'ngTableFilterRowController',\n        controllerAs: '$ctrl'\n    };\n    return directive;\n}\nexports.ngTableFilterRow = ngTableFilterRow;\n\n\n/***/ },\n/* 20 */\n/***/ function(module, exports) {\n\n\"use strict\";\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\"use strict\";\n/**\n * Controller for the {@link ngTableFilterRow ngTableFilterRow} directive\n */\nvar NgTableFilterRowController = (function () {\n    function NgTableFilterRowController($scope, ngTableFilterConfig) {\n        this.config = ngTableFilterConfig;\n        // todo: stop doing this. Why?\n        // * scope inheritance makes it hard to know how supplies functions\n        // * scope is not a concept in angular 2\n        // make function available to filter templates\n        $scope.getFilterPlaceholderValue = this.getFilterPlaceholderValue.bind(this);\n    }\n    NgTableFilterRowController.prototype.getFilterCellCss = function (filter, layout) {\n        if (layout !== 'horizontal') {\n            return 's12';\n        }\n        var size = Object.keys(filter).length;\n        var width = parseInt((12 / size).toString(), 10);\n        return 's' + width;\n    };\n    NgTableFilterRowController.prototype.getFilterPlaceholderValue = function (filterDef, filterKey) {\n        if (typeof filterDef === 'string') {\n            return '';\n        }\n        else {\n            return filterDef.placeholder;\n        }\n    };\n    NgTableFilterRowController.$inject = ['$scope', 'ngTableFilterConfig'];\n    return NgTableFilterRowController;\n}());\nexports.NgTableFilterRowController = NgTableFilterRowController;\n\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\"use strict\";\nvar templateUrl = __webpack_require__(47);\nngTableGroupRow.$inject = [];\n/**\n * directive that renders the group header row for a table\n * @ngdoc directive\n * @example\n * ```html\n * <ng-table-group-row></ng-table-group-row>\n * ```\n */\nfunction ngTableGroupRow() {\n    var directive = {\n        restrict: 'E',\n        replace: true,\n        templateUrl: templateUrl,\n        scope: true,\n        controller: 'ngTableGroupRowController',\n        controllerAs: '$ctrl'\n    };\n    return directive;\n}\nexports.ngTableGroupRow = ngTableGroupRow;\n\n\n/***/ },\n/* 22 */\n/***/ function(module, exports) {\n\n\"use strict\";\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\"use strict\";\n/**\n * Controller for the {@link ngTableGroupRow ngTableGroupRow} directive\n */\nvar NgTableGroupRowController = (function () {\n    function NgTableGroupRowController($scope) {\n        var _this = this;\n        this.$scope = $scope;\n        this.groupFns = [];\n        $scope.$watch('params.group()', function (newGrouping) {\n            _this.setGroup(newGrouping);\n        }, true);\n    }\n    NgTableGroupRowController.prototype.getGroupables = function () {\n        var _this = this;\n        var groupableCols = this.$scope.$columns.filter(function ($column) { return !!$column.groupable(_this.$scope); });\n        return this.groupFns.concat(groupableCols);\n    };\n    NgTableGroupRowController.prototype.getGroupTitle = function (group) {\n        return this.isGroupingFunc(group) ? group.title : group.title(this.$scope);\n    };\n    NgTableGroupRowController.prototype.getVisibleColumns = function () {\n        var _this = this;\n        return this.$scope.$columns.filter(function ($column) { return $column.show(_this.$scope); });\n    };\n    NgTableGroupRowController.prototype.groupBy = function (group) {\n        if (this.isSelectedGroup(group)) {\n            this.changeSortDirection();\n        }\n        else {\n            if (this.isGroupingFunc(group)) {\n                this.$scope.params.group(group);\n            }\n            else {\n                // it's OK, we know that groupable will return a string\n                // this is guaranteed by getGroupables returning only\n                // columns that return (truthy) strings\n                this.$scope.params.group(group.groupable(this.$scope));\n            }\n        }\n    };\n    NgTableGroupRowController.prototype.isSelectedGroup = function (group) {\n        if (this.isGroupingFunc(group)) {\n            return group === this.$scope.$selGroup;\n        }\n        else {\n            return group.groupable(this.$scope) === this.$scope.$selGroup;\n        }\n    };\n    NgTableGroupRowController.prototype.toggleDetail = function () {\n        this.$scope.params.settings().groupOptions.isExpanded = !this.$scope.params.settings().groupOptions.isExpanded;\n        return this.$scope.params.reload();\n    };\n    NgTableGroupRowController.prototype.changeSortDirection = function () {\n        var newDirection;\n        if (this.$scope.params.hasGroup(this.$scope.$selGroup, 'asc')) {\n            newDirection = 'desc';\n        }\n        else if (this.$scope.params.hasGroup(this.$scope.$selGroup, 'desc')) {\n            newDirection = '';\n        }\n        else {\n            newDirection = 'asc';\n        }\n        this.$scope.params.group(this.$scope.$selGroup, newDirection);\n    };\n    NgTableGroupRowController.prototype.findGroupColumn = function (groupKey) {\n        var _this = this;\n        return this.$scope.$columns.filter(function ($column) { return $column.groupable(_this.$scope) === groupKey; })[0];\n    };\n    NgTableGroupRowController.prototype.isGroupingFunc = function (val) {\n        return typeof val === 'function';\n    };\n    NgTableGroupRowController.prototype.setGroup = function (grouping) {\n        var existingGroupCol = this.findGroupColumn(this.$scope.$selGroup);\n        if (existingGroupCol && existingGroupCol.show.assign) {\n            existingGroupCol.show.assign(this.$scope, true);\n        }\n        if (this.isGroupingFunc(grouping)) {\n            this.groupFns = [grouping];\n            this.$scope.$selGroup = grouping;\n            this.$scope.$selGroupTitle = grouping.title;\n        }\n        else {\n            // note: currently only one group is implemented\n            var groupKey = Object.keys(grouping || {})[0];\n            var groupedColumn = this.findGroupColumn(groupKey);\n            if (groupedColumn) {\n                this.$scope.$selGroupTitle = groupedColumn.title(this.$scope);\n                this.$scope.$selGroup = groupKey;\n                if (groupedColumn.show.assign) {\n                    groupedColumn.show.assign(this.$scope, false);\n                }\n            }\n        }\n    };\n    NgTableGroupRowController.$inject = ['$scope'];\n    return NgTableGroupRowController;\n}());\nexports.NgTableGroupRowController = NgTableGroupRowController;\n\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\"use strict\";\nvar ng1 = __webpack_require__(0);\nngTablePagination.$inject = ['$compile', '$document', 'ngTableEventsChannel'];\n/**\n * Directive that renders the table pagination controls\n * @ngdoc directive\n */\nfunction ngTablePagination($compile, $document, ngTableEventsChannel) {\n    return {\n        restrict: 'A',\n        scope: {\n            'params': '=ngTablePagination',\n            'templateUrl': '='\n        },\n        replace: false,\n        link: function (scope, element /*, attrs*/) {\n            ngTableEventsChannel.onAfterReloadData(function (pubParams) {\n                scope.pages = pubParams.generatePagesArray();\n            }, scope, function (pubParams) {\n                return pubParams === scope.params;\n            });\n            scope.$watch('templateUrl', function (templateUrl) {\n                if (templateUrl === undefined) {\n                    return;\n                }\n                var template = ng1.element('<div ng-include=\"templateUrl\"></div>', $document);\n                element.append(template);\n                $compile(template)(scope);\n            });\n        }\n    };\n}\nexports.ngTablePagination = ngTablePagination;\n\n\n/***/ },\n/* 24 */\n/***/ function(module, exports) {\n\n\"use strict\";\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\"use strict\";\nngTableSelectFilterDs.$inject = [];\n/**\n * Takes the array returned by $column.filterData and makes it available as `$selectData` on the `$scope`.\n *\n * The resulting `$selectData` array will contain an extra item that is suitable to represent the user\n * \"deselecting\" an item from a `<select>` tag\n *\n * This directive is is focused on providing a datasource to an `ngOptions` directive\n */\nfunction ngTableSelectFilterDs() {\n    // note: not using isolated or child scope \"by design\"\n    // this is to allow this directive to be combined with other directives that do\n    var directive = {\n        restrict: 'A',\n        controller: NgTableSelectFilterDsController\n    };\n    return directive;\n}\nexports.ngTableSelectFilterDs = ngTableSelectFilterDs;\n/**\n * @private\n */\nvar NgTableSelectFilterDsController = (function () {\n    function NgTableSelectFilterDsController($scope, $parse, $attrs, $q) {\n        var _this = this;\n        this.$scope = $scope;\n        this.$attrs = $attrs;\n        this.$q = $q;\n        this.$column = $parse($attrs.ngTableSelectFilterDs)($scope);\n        $scope.$watch(function () { return _this.$column && _this.$column.data; }, function () { _this.bindDataSource(); });\n    }\n    NgTableSelectFilterDsController.prototype.bindDataSource = function () {\n        var _this = this;\n        this.getSelectListData(this.$column).then(function (data) {\n            if (data && !_this.hasEmptyOption(data)) {\n                data.unshift({ id: '', title: '' });\n            }\n            data = data || [];\n            _this.$scope.$selectData = data;\n        });\n    };\n    NgTableSelectFilterDsController.prototype.hasEmptyOption = function (data) {\n        var isMatch;\n        for (var i = 0; i < data.length; i++) {\n            var item = data[i];\n            if (item && item.id === '') {\n                isMatch = true;\n                break;\n            }\n        }\n        return isMatch;\n    };\n    NgTableSelectFilterDsController.prototype.getSelectListData = function ($column) {\n        var dataInput = $column.data;\n        if (dataInput instanceof Array) {\n            return this.$q.when(dataInput);\n        }\n        else {\n            return this.$q.when(dataInput && dataInput());\n        }\n    };\n    NgTableSelectFilterDsController.$inject = ['$scope', '$parse', '$attrs', '$q'];\n    return NgTableSelectFilterDsController;\n}());\nexports.NgTableSelectFilterDsController = NgTableSelectFilterDsController;\n\n\n/***/ },\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\"use strict\";\nvar templateUrl = __webpack_require__(50);\nngTableSorterRow.$inject = [];\n/**\n * directive that renders the sorting header row for a table\n * @ngdoc directive\n * @example\n * ```html\n * <ng-table-sorter-row></ng-table-sorter-row>\n * ```\n */\nfunction ngTableSorterRow() {\n    var directive = {\n        restrict: 'E',\n        replace: true,\n        templateUrl: templateUrl,\n        scope: true,\n        controller: 'ngTableSorterRowController',\n        controllerAs: '$ctrl'\n    };\n    return directive;\n}\nexports.ngTableSorterRow = ngTableSorterRow;\n\n\n/***/ },\n/* 26 */\n/***/ function(module, exports) {\n\n\"use strict\";\n\"use strict\";\n/**\n * Controller for the {@link ngTableSorterRow ngTableSorterRow} directive\n */\nvar NgTableSorterRowController = (function () {\n    function NgTableSorterRowController($scope) {\n        this.$scope = $scope;\n    }\n    NgTableSorterRowController.prototype.sortBy = function ($column, event) {\n        var parsedSortable = $column.sortable && $column.sortable();\n        if (!parsedSortable || typeof parsedSortable !== 'string') {\n            return;\n        }\n        else {\n            var defaultSort = this.$scope.params.settings().defaultSort;\n            var inverseSort = (defaultSort === 'asc' ? 'desc' : 'asc');\n            var sorting = this.$scope.params.sorting() && this.$scope.params.sorting()[parsedSortable] && (this.$scope.params.sorting()[parsedSortable] === defaultSort);\n            var sortingParams = (event.ctrlKey || event.metaKey) ? this.$scope.params.sorting() : {};\n            sortingParams[parsedSortable] = (sorting ? inverseSort : defaultSort);\n            this.$scope.params.parameters({\n                sorting: sortingParams\n            });\n        }\n    };\n    NgTableSorterRowController.$inject = ['$scope'];\n    return NgTableSorterRowController;\n}());\nexports.NgTableSorterRowController = NgTableSorterRowController;\n\n\n/***/ },\n/* 27 */\n/***/ function(module, exports) {\n\n\"use strict\";\n\"use strict\";\n\n\n/***/ },\n/* 28 */\n/***/ function(module, exports) {\n\n\"use strict\";\n\"use strict\";\n\n\n/***/ },\n/* 29 */\n/***/ function(module, exports) {\n\n\"use strict\";\n\"use strict\";\n\n\n/***/ },\n/* 30 */\n/***/ function(module, exports) {\n\n\"use strict\";\n\"use strict\";\n\n\n/***/ },\n/* 31 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\"use strict\";\nvar ng1 = __webpack_require__(0);\n/**\n * Implementation of the {@link IDefaultGetDataProvider} interface\n */\nvar NgTableDefaultGetDataProvider = (function () {\n    function NgTableDefaultGetDataProvider() {\n        /**\n         * The name of a angular filter that knows how to apply the values returned by\n         * `NgTableParams.filter()` to restrict an array of data.\n         * (defaults to the angular `filter` filter service)\n         */\n        this.filterFilterName = 'filter';\n        /**\n         * The name of a angular filter that knows how to apply the values returned by\n        * `NgTableParams.orderBy()` to sort an array of data.\n        * (defaults to the angular `orderBy` filter service)\n        */\n        this.sortingFilterName = 'orderBy';\n        var provider = this;\n        this.$get = ngTableDefaultGetData;\n        ngTableDefaultGetData.$inject = ['$filter', 'ngTableEventsChannel'];\n        function ngTableDefaultGetData($filter, ngTableEventsChannel) {\n            var defaultDataOptions = { applyFilter: true, applySort: true, applyPaging: true };\n            getData.applyPaging = applyPaging;\n            getData.getFilterFn = getFilterFn;\n            getData.getOrderByFn = getOrderByFn;\n            return getData;\n            function getFilterFn(params) {\n                var filterOptions = params.settings().filterOptions;\n                if (ng1.isFunction(filterOptions.filterFn)) {\n                    return filterOptions.filterFn;\n                }\n                else {\n                    return $filter(filterOptions.filterFilterName || provider.filterFilterName);\n                }\n            }\n            function getOrderByFn(params) {\n                return $filter(provider.sortingFilterName);\n            }\n            function applyFilter(data, params) {\n                if (!params.hasFilter()) {\n                    return data;\n                }\n                var filter = params.filter(true);\n                var filterKeys = Object.keys(filter);\n                var parsedFilter = filterKeys.reduce(function (result, key) {\n                    result = setPath(result, filter[key], key);\n                    return result;\n                }, {});\n                var filterFn = getFilterFn(params);\n                return filterFn.call(params, data, parsedFilter, params.settings().filterOptions.filterComparator);\n            }\n            function applyPaging(data, params) {\n                var pagedData = data.slice((params.page() - 1) * params.count(), params.page() * params.count());\n                params.total(data.length); // set total for recalc pagination\n                return pagedData;\n            }\n            function applySort(data, params) {\n                var orderBy = params.orderBy();\n                var orderByFn = getOrderByFn(params);\n                return orderBy.length ? orderByFn(data, orderBy) : data;\n            }\n            function getData(data, params) {\n                if (data == null) {\n                    return [];\n                }\n                var options = ng1.extend({}, defaultDataOptions, params.settings().dataOptions);\n                var fData = options.applyFilter ? applyFilter(data, params) : data;\n                ngTableEventsChannel.publishAfterDataFiltered(params, fData);\n                var orderedData = options.applySort ? applySort(fData, params) : fData;\n                ngTableEventsChannel.publishAfterDataSorted(params, orderedData);\n                return options.applyPaging ? applyPaging(orderedData, params) : orderedData;\n            }\n            // Sets the value at any depth in a nested object based on the path\n            // note: adapted from: underscore-contrib#setPath\n            function setPath(obj, value, path) {\n                var keys = path.split('.');\n                var ret = obj;\n                var lastKey = keys[keys.length - 1];\n                var target = ret;\n                var parentPathKeys = keys.slice(0, keys.length - 1);\n                parentPathKeys.forEach(function (key) {\n                    if (!target.hasOwnProperty(key)) {\n                        target[key] = {};\n                    }\n                    target = target[key];\n                });\n                target[lastKey] = value;\n                return ret;\n            }\n        }\n    }\n    return NgTableDefaultGetDataProvider;\n}());\nexports.NgTableDefaultGetDataProvider = NgTableDefaultGetDataProvider;\n\n\n/***/ },\n/* 32 */\n/***/ function(module, exports) {\n\n\"use strict\";\n\"use strict\";\n\n\n/***/ },\n/* 33 */\n/***/ function(module, exports) {\n\n\"use strict\";\n\"use strict\";\n\n\n/***/ },\n/* 34 */\n/***/ function(module, exports) {\n\n\"use strict\";\n\"use strict\";\n\n\n/***/ },\n/* 35 */\n/***/ function(module, exports) {\n\n\"use strict\";\n\"use strict\";\n\n\n/***/ },\n/* 36 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n__export(__webpack_require__(33));\n__export(__webpack_require__(34));\n__export(__webpack_require__(35));\n\n\n/***/ },\n/* 37 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n__export(__webpack_require__(4));\n__export(__webpack_require__(6));\n__export(__webpack_require__(5));\n__export(__webpack_require__(38));\n\n\n/***/ },\n/* 38 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\"use strict\";\nvar ng1 = __webpack_require__(0);\nvar util_1 = __webpack_require__(11);\nngTableDefaultGetGroups.$inject = ['$q', 'ngTableDefaultGetData'];\n/**\n * Implementation of the {@link IDefaultGetData IDefaultGetData} interface\n *\n * @ngdoc service\n */\nfunction ngTableDefaultGetGroups($q, ngTableDefaultGetData) {\n    return getGroups;\n    function getGroups(params) {\n        var group = params.group();\n        var groupFn;\n        var sortDirection = undefined;\n        if (util_1.isGroupingFun(group)) {\n            groupFn = group;\n            sortDirection = group.sortDirection;\n        }\n        else {\n            // currently support for only one group implemented\n            var groupField_1 = Object.keys(group)[0];\n            sortDirection = group[groupField_1];\n            groupFn = function (item) {\n                return getPath(item, groupField_1);\n            };\n        }\n        var settings = params.settings();\n        var originalDataOptions = settings.dataOptions;\n        settings.dataOptions = { applyPaging: false };\n        var getData = settings.getData;\n        var gotData = $q.when(getData(params));\n        return gotData.then(function (data) {\n            var groups = {};\n            ng1.forEach(data, function (item) {\n                var groupName = groupFn(item);\n                groups[groupName] = groups[groupName] || {\n                    data: [],\n                    $hideRows: !settings.groupOptions.isExpanded,\n                    value: groupName\n                };\n                groups[groupName].data.push(item);\n            });\n            var result = [];\n            for (var i in groups) {\n                result.push(groups[i]);\n            }\n            if (sortDirection) {\n                var orderByFn = ngTableDefaultGetData.getOrderByFn();\n                var orderBy = util_1.convertSortToOrderBy({\n                    value: sortDirection\n                });\n                result = orderByFn(result, orderBy);\n            }\n            return ngTableDefaultGetData.applyPaging(result, params);\n        }).finally(function () {\n            // restore the real options\n            settings.dataOptions = originalDataOptions;\n        });\n    }\n}\nexports.ngTableDefaultGetGroups = ngTableDefaultGetGroups;\n/**\n * @private\n */\nfunction getPath(obj, ks) {\n    // origianl source https://github.com/documentcloud/underscore-contrib\n    var keys;\n    if (typeof ks === \"string\") {\n        keys = ks.split(\".\");\n    }\n    else {\n        keys = ks;\n    }\n    // If we have reached an undefined property\n    // then stop executing and return undefined\n    if (obj === undefined)\n        return void 0;\n    // If the path array has no more elements, we've reached\n    // the intended property and return its value\n    if (keys.length === 0)\n        return obj;\n    // If we still have elements in the path array and the current\n    // value is null, stop executing and return undefined\n    if (obj === null)\n        return void 0;\n    return getPath(obj[keys[0]], keys.slice(1));\n}\n\n\n/***/ },\n/* 39 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n__export(__webpack_require__(4));\n__export(__webpack_require__(6));\n__export(__webpack_require__(5));\n\n\n/***/ },\n/* 40 */\n/***/ function(module, exports) {\n\n\"use strict\";\n\"use strict\";\n\n\n/***/ },\n/* 41 */\n/***/ function(module, exports) {\n\n\"use strict\";\n\"use strict\";\n\n\n/***/ },\n/* 42 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar path = 'ng-table/filterRow.html';\nvar html = \"<tr ng-show=show_filter class=ng-table-filters> <th data-title-text=\\\"{{$column.titleAlt(this) || $column.title(this)}}\\\" ng-repeat=\\\"$column in $columns\\\" ng-if=$column.show(this) class=\\\"filter {{$column.class(this)}}\\\" ng-class=\\\"params.settings().filterOptions.filterLayout === 'horizontal' ? 'filter-horizontal' : ''\\\"> <div ng-repeat=\\\"(name, filter) in $column.filter(this)\\\" ng-include=$ctrl.config.getTemplateUrl(filter) class=filter-cell ng-class=\\\"[$ctrl.getFilterCellCss($column.filter(this), params.settings().filterOptions.filterLayout), $last ? 'last' : '']\\\"> </div> </th> </tr> \";\nvar angular = __webpack_require__(0);\nangular.module('ng').run(['$templateCache', function(c) { c.put(path, html) }]);\nmodule.exports = path;\n\n/***/ },\n/* 43 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar path = 'ng-table/filters/number.html';\nvar html = \"<input type=number name={{name}} ng-disabled=$filterRow.disabled ng-model=params.filter()[name] class=\\\"input-filter form-control\\\" placeholder=\\\"{{getFilterPlaceholderValue(filter, name)}}\\\"/> \";\nvar angular = __webpack_require__(0);\nangular.module('ng').run(['$templateCache', function(c) { c.put(path, html) }]);\nmodule.exports = path;\n\n/***/ },\n/* 44 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar path = 'ng-table/filters/select-multiple.html';\nvar html = \"<select ng-options=\\\"data.id as data.title for data in $column.data\\\" ng-disabled=$filterRow.disabled multiple=multiple ng-multiple=true ng-model=params.filter()[name] class=\\\"filter filter-select-multiple form-control\\\" name={{name}}> </select> \";\nvar angular = __webpack_require__(0);\nangular.module('ng').run(['$templateCache', function(c) { c.put(path, html) }]);\nmodule.exports = path;\n\n/***/ },\n/* 45 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar path = 'ng-table/filters/select.html';\nvar html = \"<select ng-options=\\\"data.id as data.title for data in $selectData\\\" ng-table-select-filter-ds=$column ng-disabled=$filterRow.disabled ng-model=params.filter()[name] class=\\\"filter filter-select form-control\\\" name={{name}}> <option style=display:none value=\\\"\\\"></option> </select> \";\nvar angular = __webpack_require__(0);\nangular.module('ng').run(['$templateCache', function(c) { c.put(path, html) }]);\nmodule.exports = path;\n\n/***/ },\n/* 46 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar path = 'ng-table/filters/text.html';\nvar html = \"<input type=text name={{name}} ng-disabled=$filterRow.disabled ng-model=params.filter()[name] class=\\\"input-filter form-control\\\" placeholder=\\\"{{getFilterPlaceholderValue(filter, name)}}\\\"/> \";\nvar angular = __webpack_require__(0);\nangular.module('ng').run(['$templateCache', function(c) { c.put(path, html) }]);\nmodule.exports = path;\n\n/***/ },\n/* 47 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar path = 'ng-table/groupRow.html';\nvar html = \"<tr ng-if=params.hasGroup() ng-show=$groupRow.show class=ng-table-group-header> <th colspan={{$ctrl.getVisibleColumns().length}} class=sortable ng-class=\\\"{\\n                    'sort-asc': params.hasGroup($selGroup, 'asc'),\\n                    'sort-desc':params.hasGroup($selGroup, 'desc')\\n                  }\\\"> <a href=\\\"\\\" ng-click=\\\"isSelectorOpen = !isSelectorOpen\\\" class=ng-table-group-selector> <strong class=sort-indicator>{{$selGroupTitle}}</strong> <button class=\\\"btn btn-default btn-xs ng-table-group-close\\\" ng-click=\\\"$groupRow.show = false; $event.preventDefault(); $event.stopPropagation();\\\"> <span class=\\\"glyphicon glyphicon-remove\\\"></span> </button> <button class=\\\"btn btn-default btn-xs ng-table-group-toggle\\\" ng-click=\\\"$ctrl.toggleDetail(); $event.preventDefault(); $event.stopPropagation();\\\"> <span class=glyphicon ng-class=\\\"{\\n                    'glyphicon-resize-small': params.settings().groupOptions.isExpanded,\\n                    'glyphicon-resize-full': !params.settings().groupOptions.isExpanded\\n                }\\\"></span> </button> </a> <div class=list-group ng-if=isSelectorOpen> <a href=\\\"\\\" class=list-group-item ng-repeat=\\\"group in $ctrl.getGroupables()\\\" ng-click=$ctrl.groupBy(group)> <strong>{{ $ctrl.getGroupTitle(group)}}</strong> <strong ng-class=\\\"$ctrl.isSelectedGroup(group) && 'sort-indicator'\\\"></strong> </a> </div> </th> </tr> \";\nvar angular = __webpack_require__(0);\nangular.module('ng').run(['$templateCache', function(c) { c.put(path, html) }]);\nmodule.exports = path;\n\n/***/ },\n/* 48 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar path = 'ng-table/header.html';\nvar html = \"<ng-table-group-row></ng-table-group-row> <ng-table-sorter-row></ng-table-sorter-row> <ng-table-filter-row></ng-table-filter-row> \";\nvar angular = __webpack_require__(0);\nangular.module('ng').run(['$templateCache', function(c) { c.put(path, html) }]);\nmodule.exports = path;\n\n/***/ },\n/* 49 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar path = 'ng-table/pager.html';\nvar html = \"<div class=\\\"ng-cloak ng-table-pager\\\" ng-if=params.data.length> <div ng-if=params.settings().counts.length class=\\\"ng-table-counts btn-group pull-right\\\"> <button ng-repeat=\\\"count in params.settings().counts\\\" type=button ng-class=\\\"{'active':params.count() == count}\\\" ng-click=params.count(count) class=\\\"btn btn-default\\\"> <span ng-bind=count></span> </button> </div> <ul ng-if=pages.length class=\\\"pagination ng-table-pagination\\\"> <li class=page-item ng-class=\\\"{'disabled': !page.active && !page.current, 'active': page.current}\\\" ng-repeat=\\\"page in pages\\\" ng-switch=page.type> <a class=page-link ng-switch-when=prev ng-click=params.page(page.number) href=\\\"\\\">&laquo;</a> <a class=page-link ng-switch-when=first ng-click=params.page(page.number) href=\\\"\\\"><span ng-bind=page.number></span></a> <a class=page-link ng-switch-when=page ng-click=params.page(page.number) href=\\\"\\\"><span ng-bind=page.number></span></a> <a class=page-link ng-switch-when=more ng-click=params.page(page.number) href=\\\"\\\">&#8230;</a> <a class=page-link ng-switch-when=last ng-click=params.page(page.number) href=\\\"\\\"><span ng-bind=page.number></span></a> <a class=page-link ng-switch-when=next ng-click=params.page(page.number) href=\\\"\\\">&raquo;</a> </li> </ul> </div> \";\nvar angular = __webpack_require__(0);\nangular.module('ng').run(['$templateCache', function(c) { c.put(path, html) }]);\nmodule.exports = path;\n\n/***/ },\n/* 50 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar path = 'ng-table/sorterRow.html';\nvar html = \"<tr class=ng-table-sort-header> <th title={{$column.headerTitle(this)}} ng-repeat=\\\"$column in $columns\\\" ng-class=\\\"{\\n                    'sortable': $column.sortable(this),\\n                    'sort-asc': params.sorting()[$column.sortable(this)]=='asc',\\n                    'sort-desc': params.sorting()[$column.sortable(this)]=='desc'\\n                  }\\\" ng-click=\\\"$ctrl.sortBy($column, $event)\\\" ng-if=$column.show(this) ng-init=\\\"template = $column.headerTemplateURL(this)\\\" class=\\\"header {{$column.class(this)}}\\\"> <div ng-if=!template class=ng-table-header ng-class=\\\"{'sort-indicator': params.settings().sortingIndicator == 'div'}\\\"> <span ng-bind=$column.title(this) ng-class=\\\"{'sort-indicator': params.settings().sortingIndicator == 'span'}\\\"></span> </div> <div ng-if=template ng-include=template></div> </th> </tr> \";\nvar angular = __webpack_require__(0);\nangular.module('ng').run(['$templateCache', function(c) { c.put(path, html) }]);\nmodule.exports = path;\n\n/***/ },\n/* 51 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nvar ng1 = __webpack_require__(0);\nvar core_1 = __webpack_require__(1);\nvar browser_1 = __webpack_require__(2);\nvar ngTableModule = ng1.module('ngTable', [core_1.ngTableCoreModule.name, browser_1.ngTableBrowserModule.name]);\nexports.ngTableModule = ngTableModule;\n__export(__webpack_require__(1));\n__export(__webpack_require__(2));\n\n\n/***/ }\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// ng-table.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmory imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmory exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 51);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap f72b9990c4e9da3f352c","module.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"angular\"\n// module id = 0\n// module chunks = 0","import * as angular from 'angular';\nimport { NgTableDefaultGetDataProvider, IDefaultGetData } from './data';\nimport { IGroupSettings, ngTableDefaultGetGroups } from './grouping';\nimport { ngTableDefaults, IDefaults } from './ngTableDefaults';\nimport { NgTableSettings, ISettings } from './ngTableSettings';\nimport { NgTableParams } from './ngTableParams';\nimport { NgTableEventsChannel } from './ngTableEventsChannel';\n\nconst ngTableCoreModule = angular.module('ngTable-core', [])\n    .provider('ngTableDefaultGetData', NgTableDefaultGetDataProvider)\n    .factory('ngTableDefaultGetGroups', ngTableDefaultGetGroups)\n    .value('ngTableDefaults',ngTableDefaults)\n    .service('ngTableEventsChannel', NgTableEventsChannel)\n    .service('ngTableSettings', NgTableSettings)\n    .run(NgTableParams.init);\n\n// note: if you are using ES6 or typescript prefer:\n// import { NgTableParams } from 'ng-table';\nngTableCoreModule.value('NgTableParams', NgTableParams)\n\nexport { ngTableCoreModule };\n\nexport { IDefaults } from './ngTableDefaults';\nexport * from './ngTableEventsChannel';\nexport { ISettings } from './ngTableSettings';\nexport * from './ngTableParams';\nexport * from './data';\nexport * from './filtering';\nexport * from './grouping/publicExports';\nexport * from './paging';\nexport * from './sorting';\n\n\n\n// WEBPACK FOOTER //\n// ./~/angular1-template-loader!./src/core/index.ts","import * as angular from 'angular';\nimport { ngTable } from './ngTable.directive';\nimport { NgTableColumn } from './ngTableColumn';\nimport { ngTableColumnsBinding } from './ngTableColumnsBinding.directive';\nimport { NgTableController } from './ngTableController';\nimport { ngTableDynamic } from './ngTableDynamic.directive';\nimport { NgTableFilterConfigProvider, NgTableFilterConfig } from './ngTableFilterConfig';\nimport { ngTableFilterRow } from './ngTableFilterRow.directive';\nimport { NgTableFilterRowController } from './ngTableFilterRowController';\nimport { ngTableGroupRow } from './ngTableGroupRow.directive';\nimport { NgTableGroupRowController } from './ngTableGroupRowController';\nimport { ngTablePagination } from './ngTablePagination.directive';\nimport { ngTableSelectFilterDs } from './ngTableSelectFilterDs.directive';\nimport { ngTableSorterRow } from './ngTableSorterRow.directive';\nimport { NgTableSorterRowController } from './ngTableSorterRowController';\nimport './filters/number.html';\nimport './filters/select.html';\nimport './filters/select-multiple.html';\nimport './filters/text.html';\nimport './pager.html';\nimport './header.html';\n\nconst ngTableBrowserModule = angular.module('ngTable-browser', [])\n    .directive('ngTable', ngTable)\n    .service('ngTableColumn', NgTableColumn)\n    .directive('ngTableColumnsBinding', ngTableColumnsBinding)\n    .controller('ngTableController', NgTableController)\n    .directive('ngTableDynamic', ngTableDynamic)\n    .provider('ngTableFilterConfig', NgTableFilterConfigProvider)\n    .directive('ngTableFilterRow', ngTableFilterRow)\n    .controller('ngTableFilterRowController', NgTableFilterRowController)\n    .directive('ngTableGroupRow', ngTableGroupRow)\n    .controller('ngTableGroupRowController', NgTableGroupRowController)\n    .directive('ngTablePagination', ngTablePagination)\n    .directive('ngTableSelectFilterDs', ngTableSelectFilterDs)\n    .directive('ngTableSorterRow', ngTableSorterRow)\n    .controller('ngTableSorterRowController', NgTableSorterRowController);\n\nexport * from './public-interfaces';\nexport { NgTableController, NgTableFilterConfigProvider, NgTableFilterConfig, ngTableBrowserModule };\n\n\n// WEBPACK FOOTER //\n// ./~/angular1-template-loader!./src/browser/index.ts","export * from './dataSettings';\nexport * from './getData';\nexport * from './interceptor';\nexport * from './ngTableDefaultGetData';\nexport * from './results';\n\n\n// WEBPACK FOOTER //\n// ./~/angular1-template-loader!./src/core/data/index.ts","/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\nimport { IParamValues } from './ngTableParams';\nimport { ISettings } from './ngTableSettings';\n\n\n/**\n * An angular value object that allow for overriding of the initial default values used when constructing\n * an instance of `NgTableParams`\n */\nexport interface IDefaults {\n    params?: IParamValues<any>;\n    settings?: ISettings<any>\n}\n\n/**\n * Default values for ngTable\n */\nexport let ngTableDefaults : IDefaults = {\n    params: {},\n    settings: {}\n};\n\n\n// WEBPACK FOOTER //\n// ./~/angular1-template-loader!./src/core/ngTableDefaults.ts","/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\nimport * as ng1 from 'angular';\nimport { IScope } from 'angular';\nimport { DataResult, IDefaultGetData } from './data';\nimport { IPageButton } from './paging';\nimport { InternalTableParams, NgTableParams } from './ngTableParams';\n\n\n/**\n * Alias for the types that can be used to filter events\n */\nexport type EventSelector<T> = NgTableParams<T> | IEventSelectorFunc\n\n/**\n * Signature of the event hander that is registered to receive the *afterCreated* event\n */\nexport interface IAfterCreatedListener {\n    (publisher: NgTableParams<any>): any\n}\n/**\n * Signature of the event hander that is registered to receive the *afterReloadData* event\n */\nexport interface IAfterReloadDataListener<T> {\n    (publisher: NgTableParams<T>, newData: DataResult<T>[], oldData: DataResult<T>[]): any\n}\n/**\n * Signature of the event hander that is registered to receive the *datasetChanged* event\n */\nexport interface IDatasetChangedListener<T> {\n    (publisher: NgTableParams<T>, newDataset: T[], oldDataset: T[]): any\n}\n/**\n * Signature of the function used to filter the events to only specific instances of \n * {@link NgTableParams}\n */\nexport interface IEventSelectorFunc {\n    (publisher: NgTableParams<any>): boolean\n}\n/**\n * Signature of the event hander that is registered to receive the *pagesChanged* event\n */\nexport interface IPagesChangedListener {\n    (publisher: NgTableParams<any>, newPages: IPageButton[], oldPages: IPageButton[]): any\n}\n/**\n* Signature of the event hander that is registered to receive the *afterDataFiltered* event\n*/\nexport interface IAfterDataFilteredListener<T> {\n    (publisher: NgTableParams<T>, newData: DataResult<T>[] ): any\n}\n/**\n* Signature of the event hander that is registered to receive the *afterDataSorted* event\n*/\nexport interface IAfterDataSortedListener<T> {\n    (publisher: NgTableParams<T>, newData: DataResult<T>[] ): any\n}\n\n/**\n * Signature of the function used to explicitly unregister an event handler so that it stops\n * receiving notifications\n */\nexport interface IUnregistrationFunc {\n    (): void\n}\n\n/**\n * Strongly typed pub/sub for {@link NgTableParams}\n *\n * Supported events:\n *\n * * afterCreated - raised when a new instance of {@link NgTableParams} has finished being constructed\n * * afterReloadData - raised when the {@link NgTableParams} `reload` method has finished loading new data\n * * datasetChanged - raised when {@link ISettings} `dataset` receives a new data array\n * * pagesChanged - raised when a new pages array has been generated\n */\nexport interface NgTableEventsChannel {\n    /**\n     * Subscribe to receive notification whenever a new `NgTableParams` instance has finished being constructed.\n     * Optionally supply an `eventFilter` to restrict which events that should trigger the `listener` to be called. Supply a\n     * `scope` to have angular automatically unregister the listener when the `scope` is destroyed.\n     *\n     * @param listener the function that will be called when the event fires\n     * @param scope the angular `$scope` that will limit the lifetime of the event subscription\n     * @param eventFilter a predicate function that should return true to receive the event\n     * @return a unregistration function that when called will unregister the `listener`\n     */\n    onAfterCreated(listener: IAfterCreatedListener, scope: IScope, eventFilter?: IEventSelectorFunc): IUnregistrationFunc;\n    /**\n     * Subscribe to receive notification whenever a new `NgTableParams` instance has finished being constructed.\n     * Optionally supply an `eventFilter` to restrict which events that should trigger the `listener` to be called.\n     *\n     * @param listener the function that will be called when the event fires\n     * @param eventFilter a predicate function that should return true to receive the event\n     * @return a unregistration function that when called will unregister the `listener`\n     */\n    onAfterCreated(listener: IAfterCreatedListener, eventFilter?: IEventSelectorFunc): IUnregistrationFunc;\n    /**\n     * Subscribe to receive notification whenever the `reload` method of an `NgTableParams` instance has successfully executed\n     * Optionally supply an `eventFilter` to restrict which events that should trigger the `listener` to be called. Supply a\n     * `scope` to have angular automatically unregister the listener when the `scope` is destroyed.\n     *\n     * @param listener the function that will be called when the event fires\n     * @param scope the angular `$scope` that will limit the lifetime of the event subscription\n     * @param eventFilter either the specific `NgTableParams` instance you want to receive events for or a predicate function that should return true to receive the event\n     * @return a unregistration function that when called will unregister the `listener`\n     */\n    onAfterReloadData<T>(listener: IAfterReloadDataListener<T>, scope: IScope, eventFilter?: EventSelector<T>): IUnregistrationFunc;\n    /**\n     * Subscribe to receive notification whenever the `reload` method of an `NgTableParams` instance has successfully executed\n     * Optionally supply an `eventFilter` to restrict which events that should trigger the `listener` to be called.\n     *\n     * @param listener the function that will be called when the event fires\n     * @param eventFilter a predicate function that should return true to receive the event\n     * @return a unregistration function that when called will unregister the `listener`\n     */\n    onAfterReloadData<T>(listener: IAfterReloadDataListener<T>, eventFilter?: EventSelector<T>): IUnregistrationFunc;\n\n    /**\n     * Subscribe to receive notification whenever a new data rows *array* is supplied as a `settings` value to a `NgTableParams` instance.\n     * Optionally supply an `eventFilter` to restrict which events that should trigger the `listener` to be called. Supply a\n     * `scope` to have angular automatically unregister the listener when the `scope` is destroyed.\n     *\n     * @param listener the function that will be called when the event fires\n     * @param scope the angular `$scope` that will limit the lifetime of the event subscription\n     * @param eventFilter either the specific `NgTableParams` instance you want to receive events for or a predicate function that should return true to receive the event\n     * @return a unregistration function that when called will unregister the `listener`\n     */\n    onDatasetChanged<T>(listener: IDatasetChangedListener<T>, scope: IScope, eventFilter?: EventSelector<T>): IUnregistrationFunc;\n    /**\n     * Subscribe to receive notification whenever a new data rows *array* is supplied as a `settings` value to a `NgTableParams` instance.\n     * Optionally supply an `eventFilter` to restrict which events that should trigger the `listener` to be called.\n     *\n     * @param listener the function that will be called when the event fires\n     * @param eventFilter either the specific `NgTableParams` instance you want to receive events for or a predicate function that should return true to receive the event\n     * @return a unregistration function that when called will unregister the `listener`\n     */\n    onDatasetChanged<T>(listener: IDatasetChangedListener<T>, eventFilter?: EventSelector<T>): IUnregistrationFunc;\n\n    /**\n     * Subscribe to receive notification whenever the paging buttons for an `NgTableParams` instance change\n     * Optionally supply an `eventFilter` to restrict which events that should trigger the `listener` to be called. Supply a\n     * `scope` to have angular automatically unregister the listener when the `scope` is destroyed.\n     *\n     * @param listener the function that will be called when the event fires\n     * @param scope the angular `$scope` that will limit the lifetime of the event subscription\n     * @param eventFilter either the specific `NgTableParams` instance you want to receive events for or a predicate function that should return true to receive the event\n     * @return a unregistration function that when called will unregister the `listener`\n     */\n    onPagesChanged<T>(listener: IPagesChangedListener, scope: IScope, eventFilter?: EventSelector<T>): IUnregistrationFunc;\n    /**\n     * Subscribe to receive notification whenever the paging buttons for an `NgTableParams` instance change\n     * Optionally supply an `eventFilter` to restrict which events that should trigger the `listener` to be called.\n     *\n     * @param listener the function that will be called when the event fires\n     * @param eventFilter either the specific `NgTableParams` instance you want to receive events for or a predicate function that should return true to receive the event\n     * @return a unregistration function that when called will unregister the `listener`\n     */\n    onPagesChanged<T>(listener: IPagesChangedListener, eventFilter?: EventSelector<T>): IUnregistrationFunc;\n    /**\n     * Subscribe to receive notification whenever a `ngTableDefaultGetData` instance filters data\n     * Optionally supply an `eventFilter` to restrict which events that should trigger the `listener` to be called.\n     *\n     * @param listener the function that will be called when the event fires\n     * @param scope the angular `$scope` that will limit the lifetime of the event subscription\n     * @param eventFilter either the specific `IDefaultGetData` instance you want to receive events for or a predicate function that should return true to receive the event\n     * @return a unregistration function that when called will unregister the `listener`\n     */\n    onAfterDataFiltered<T>(listener: IAfterDataFilteredListener<T>, scope: IScope, eventFilter?: EventSelector<T> ): IUnregistrationFunc;\n    /**\n     * Subscribe to receive notification whenever a `ngTableDefaultGetData` instance filters data\n     * Optionally supply an `eventFilter` to restrict which events that should trigger the `listener` to be called.\n     *\n     * @param listener the function that will be called when the event fires\n     * @param eventFilter either the specific `IDefaultGetData` instance you want to receive events for or a predicate function that should return true to receive the event\n     * @return a unregistration function that when called will unregister the `listener`\n     */\n    onAfterDataFiltered<T>(listener: IAfterDataFilteredListener<T>, eventFilter?: EventSelector<T> ): IUnregistrationFunc; \n    /**\n     * Subscribe to receive notification whenever a `ngTableDefaultGetData` instance orders data\n     * Optionally supply an `eventFilter` to restrict which events that should trigger the `listener` to be called.\n     *\n     * @param listener the function that will be called when the event fires\n     * @param scope the angular `$scope` that will limit the lifetime of the event subscription\n     * @param eventFilter either the specific `IDefaultGetData` instance you want to receive events for or a predicate function that should return true to receive the event\n     * @return a unregistration function that when called will unregister the `listener`\n     */\n    onAfterDataSorted<T>(listener: IAfterDataSortedListener<T>, scope: IScope, eventFilter?: EventSelector<T> ): IUnregistrationFunc;\n    /**\n     * Subscribe to receive notification whenever a `ngTableDefaultGetData` instance orders data\n     * Optionally supply an `eventFilter` to restrict which events that should trigger the `listener` to be called.\n     *\n     * @param listener the function that will be called when the event fires\n     * @param eventFilter either the specific `IDefaultGetData` instance you want to receive events for or a predicate function that should return true to receive the event\n     * @return a unregistration function that when called will unregister the `listener`\n     */\n    onAfterDataSorted<T>(listener: IAfterDataSortedListener<T>, eventFilter?: EventSelector<T> ): IUnregistrationFunc;\n\n\n    publishAfterCreated<T>(publisher: NgTableParams<T>): void;\n    publishAfterReloadData<T>(publisher: NgTableParams<T>, newData: T[], oldData: T[]): void;\n    publishDatasetChanged<T>(publisher: NgTableParams<T>, newDataset: T[], oldDataset: T[]): void;\n    publishPagesChanged<T>(publisher: NgTableParams<T>, newPages: IPageButton[], oldPages: IPageButton[]): void;\n    publishAfterDataFiltered<T>(publisher: NgTableParams<T>, newData: T[]): void;\n    publishAfterDataSorted<T>(params: NgTableParams<T>, newData: T[]): void;\n}\n\nexport class NgTableEventsChannel {\n    static $inject = ['$rootScope'];\n    constructor(private $rootScope: ng1.IRootScopeService) {\n        let events = this;\n        events = this.addTableParamsEvent('afterCreated', events);\n        events = this.addTableParamsEvent('afterReloadData', events);\n        events = this.addTableParamsEvent('datasetChanged', events);\n        events = this.addTableParamsEvent('pagesChanged', events);\n        events = this.addTableParamsEvent('afterDataFiltered', events);\n        events = this.addTableParamsEvent('afterDataSorted', events);\n    }\n    private addTableParamsEvent(eventName: string, target: {}) {\n        const fnName = eventName.charAt(0).toUpperCase() + eventName.substring(1);\n        const event = {\n            ['on' + fnName]: this.createEventSubscriptionFn(eventName),\n            ['publish' + fnName]: this.createPublishEventFn(eventName)\n        };\n        return ng1.extend(target, event);\n    }\n    private createPublishEventFn(eventName: string) {\n        return (...args: any[]) => {\n            this.$rootScope.$broadcast('ngTable:' + eventName, ...args);\n        }\n    }\n    private createEventSubscriptionFn(eventName: string) {\n\n        return <T>(\n            handler: (...args: any[]) => void,\n            eventSelectorOrScope: EventSelector<T> | ng1.IScope,\n            eventSelector?: EventSelector<T>) => {\n\n            let actualEvtSelector: (publisher: NgTableParams<any>) => boolean;\n            let scope: ng1.IScope = this.$rootScope;\n\n            if (isScopeLike(eventSelectorOrScope)) {\n                scope = eventSelectorOrScope;\n                actualEvtSelector = createEventSelectorFn(eventSelector);\n            } else {\n                actualEvtSelector = createEventSelectorFn(eventSelectorOrScope);\n            }\n\n            return scope.$on('ngTable:' + eventName, function (event: ng1.IAngularEvent, params: InternalTableParams<any>, ...eventArgs: any[]) {\n                // don't send events published by the internal NgTableParams created by ngTableController\n                if (params.isNullInstance) return;\n\n                const fnArgs = [params].concat(eventArgs);\n                if (actualEvtSelector.apply(this, fnArgs)) {\n                    handler.apply(this, fnArgs);\n                }\n            });\n        }\n\n        function createEventSelectorFn<T>(eventSelector: EventSelector<T>): (publisher: NgTableParams<any>) => boolean {\n            if (!eventSelector) {\n                return (publisher: NgTableParams<any>) => true;\n            } else if (isEventSelectorFunc(eventSelector)) {\n                return eventSelector\n            } else {\n                // shorthand for subscriber to only receive events from a specific publisher instance\n                return (publisher: NgTableParams<any>) => publisher === eventSelector;\n            }\n        }\n\n        function isEventSelectorFunc<T>(val: EventSelector<T>): val is (publisher: NgTableParams<any>) => boolean {\n            return typeof val === 'function';\n        }\n\n        function isScopeLike(val: any): val is ng1.IScope {\n            return val && typeof val.$new === 'function';\n        }\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./~/angular1-template-loader!./src/core/ngTableEventsChannel.ts","/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\nimport * as ng1 from 'angular';\nimport { IPromise } from 'angular';\nimport { convertSortToOrderBy, isGroupingFun } from './util';\nimport { IDefaults } from './ngTableDefaults'\nimport { NgTableEventsChannel } from './ngTableEventsChannel'\nimport { NgTableSettings, ISettings } from './ngTableSettings'\nimport { DataResult, IDataRowGroup, IGetDataFunc } from './data';\nimport { IFilterValues } from './filtering';\nimport { IGetGroupFunc, Grouping, IGroupingFunc, GroupSort, IGroupValues } from './grouping';\nimport { SortDirection, ISortingValues } from './sorting';\nimport { IPageButton } from './paging';\n\n/**\n * @private\n */\nexport interface InternalTableParams<T> extends NgTableParams<T> {\n    isNullInstance: boolean\n}\n\n/**\n * The runtime values for {@link NgTableParams} that determine the set of data rows and\n * how they are to be displayed in a table\n */\nexport interface IParamValues<T> {\n    /**\n     * The index of the \"slice\" of data rows, starting at 1, to be displayed by the table.\n     */\n    page?: number;\n    /**\n     * The number of data rows per page\n     */\n    count?: number;\n    /**\n     * The filter that should be applied to restrict the set of data rows\n     */\n    filter?: IFilterValues;\n    /**\n     * The sort order that should be applied to the data rows.\n     */\n    sorting?: ISortingValues;\n    /**\n     * The grouping that should be applied to the data rows\n     */\n    group?: string | Grouping<T>;\n}\n\n\n/**\n * @private\n */\nfunction isNumber(n: any) {\n    return !isNaN(parseFloat(n)) && isFinite(n);\n}\n\n/**\n * @private\n */\ntype Memento<T> = {\n    params: IParamValues<T>;\n    groupSortDirection?: string;\n};\n\n/**\n * Parameters manager for an ngTable directive\n */\nexport class NgTableParams<T> {\n    /**\n     * The page of data rows currently being displayed in the table\n     */\n    data: T[] = [];\n    reloadPages: () => void;\n    private defaultSettings = NgTableParams.ngTableSettings.createDefaults<T>();\n    private errParamsMemento: Memento<T>;\n    private isCommittedDataset = false;\n    isNullInstance: boolean;\n    private initialEvents: Function[] = [];\n    private prevParamsMemento: Memento<T>;\n    private _params: IParamValues<T> = {\n        page: 1,\n        count: 10,\n        filter: {},\n        sorting: {},\n        group: {}\n    };\n    private _settings = this.defaultSettings;\n    constructor(baseParameters?: IParamValues<T> | boolean, baseSettings?: ISettings<T>) {\n\n        // the ngTableController \"needs\" to create a dummy/null instance and it's important to know whether an instance\n        // is one of these\n        if (typeof baseParameters === \"boolean\") {\n            this.isNullInstance = true;\n        }\n\n        this.reloadPages = (() => {\n            let currentPages: IPageButton[];\n            return () => {\n                const oldPages = currentPages;\n                const newPages = this.generatePagesArray(this.page(), this.total(), this.count());\n                if (!ng1.equals(oldPages, newPages)) {\n                    currentPages = newPages;\n                    NgTableParams.ngTableEventsChannel.publishPagesChanged(this, newPages, oldPages);\n                }\n            }\n        })();\n\n        ng1.extend(this._params, NgTableParams.ngTableDefaults.params);\n\n        this.settings(baseSettings);\n        this.parameters(baseParameters, true);\n\n        NgTableParams.ngTableEventsChannel.publishAfterCreated(this);\n        // run events during construction after the initial create event. That way a consumer\n        // can subscribe to all events for a table without \"dropping\" an event\n        ng1.forEach(this.initialEvents, event => {\n            event();\n        });\n        this.initialEvents = null;\n    }\n    /**\n     * Returns the number of data rows per page\n     */\n    count(): number\n    /**\n     * Sets the number of data rows per page.\n     * Changes to count will cause `isDataReloadRequired` to return true\n     */\n    count(count: number): this\n    count(count?: number) {\n        // reset to first page because can be blank page\n        return count !== undefined ? this.parameters({\n            'count': count,\n            'page': 1\n        }) : this._params.count;\n    }\n    /**\n     * Returns the current filter values used to restrict the set of data rows.\n     * @param trim supply true to return the current filter minus any insignificant values\n     * (null,  undefined and empty string)\n     */\n    filter(trim?: boolean): IFilterValues\n    /**\n     * Sets filter values to the `filter` supplied; any existing filter will be removed\n     * Changes to filter will cause `isDataReloadRequired` to return true and the current `page` to be set to 1\n     */\n    filter(filter: IFilterValues): this\n    filter(filter?: IFilterValues | boolean) {\n        if (filter != null && typeof filter === 'object') {\n            return this.parameters({\n                'filter': filter,\n                'page': 1\n            });\n        } else if (filter === true) {\n            const keys = Object.keys(this._params.filter);\n            const significantFilter: IFilterValues = {};\n            for (let i = 0; i < keys.length; i++) {\n                const filterValue = this._params.filter[keys[i]];\n                if (filterValue != null && filterValue !== '') {\n                    significantFilter[keys[i]] = filterValue;\n                }\n            }\n            return significantFilter;\n        } else {\n            return this._params.filter;\n        }\n    }\n    /**\n     * Generate array of pages.\n     * When no arguments supplied, the current parameter state of this `NgTableParams` instance will be used\n     * @param currentPage Which page must be active\n     * @param totalItems  Total quantity of items\n     * @param pageSize    Quantity of items on page\n     * @param maxBlocks   Quantity of blocks for pagination\n     * @returns Array of pages\n     */\n    generatePagesArray(currentPage?: number, totalItems?: number, pageSize?: number, maxBlocks?: number) {\n        if (!arguments.length) {\n            currentPage = this.page();\n            totalItems = this.total();\n            pageSize = this.count();\n        }\n\n        let maxPage: number, maxPivotPages: number, minPage: number, numPages: number;\n        maxBlocks = maxBlocks && maxBlocks < 6 ? 6 : maxBlocks;\n\n        const pages: IPageButton[] = [];\n        numPages = Math.ceil(totalItems / pageSize);\n        if (numPages > 1) {\n            pages.push({\n                type: 'prev',\n                number: Math.max(1, currentPage - 1),\n                active: currentPage > 1\n            });\n            pages.push({\n                type: 'first',\n                number: 1,\n                active: currentPage > 1,\n                current: currentPage === 1\n            });\n            maxPivotPages = Math.round((this._settings.paginationMaxBlocks - this._settings.paginationMinBlocks) / 2);\n            minPage = Math.max(2, currentPage - maxPivotPages);\n            maxPage = Math.min(numPages - 1, currentPage + maxPivotPages * 2 - (currentPage - minPage));\n            minPage = Math.max(2, minPage - (maxPivotPages * 2 - (maxPage - minPage)));\n            let i = minPage;\n            while (i <= maxPage) {\n                if ((i === minPage && i !== 2) || (i === maxPage && i !== numPages - 1)) {\n                    pages.push({\n                        type: 'more',\n                        active: false\n                    });\n                } else {\n                    pages.push({\n                        type: 'page',\n                        number: i,\n                        active: currentPage !== i,\n                        current: currentPage === i\n                    });\n                }\n                i++;\n            }\n            pages.push({\n                type: 'last',\n                number: numPages,\n                active: currentPage !== numPages,\n                current: currentPage === numPages\n            });\n            pages.push({\n                type: 'next',\n                number: Math.min(numPages, currentPage + 1),\n                active: currentPage < numPages\n            });\n        }\n        return pages;\n    }\n    /**\n     * Returns the current grouping used to group the data rows\n     */\n    group(): Grouping<T>\n    /**\n     * Sets grouping to the `group` supplied; any existing grouping will be removed.\n     * Changes to group will cause `isDataReloadRequired` to return true and the current `page` to be set to 1\n     */\n    group(group: IGroupValues): this\n    /**\n     * Sets grouping to the `field` and `sortDirection` supplied; any existing grouping will be removed\n     * Changes to group will cause `isDataReloadRequired` to return true and the current `page` to be set to 1\n     */\n    group(field: string, sortDirection?: GroupSort): this\n    /**\n     * Sets grouping to the `group` supplied; any existing grouping will be removed.\n     * If `sortDirection` is supplied, this will be assigned to the sortDirection property of `group`\n     * Changes to group will cause `isDataReloadRequired` to return true and the current `page` to be set to 1\n     */\n    group(group: IGroupingFunc<T> | string, sortDirection?: GroupSort): this\n    group(group?: Grouping<T> | string, sortDirection?: GroupSort): string | Grouping<T> | this {\n        if (group === undefined) {\n            return this._params.group;\n        }\n\n        const newParameters: IParamValues<T> = {\n            page: 1\n        };\n        if (isGroupingFun(group) && sortDirection !== undefined) {\n            group.sortDirection = sortDirection;\n            newParameters.group = group;\n        } else if (typeof group === 'string' && sortDirection !== undefined) {\n            newParameters.group = { [group]: sortDirection };\n        } else {\n            newParameters.group = group;\n        }\n        this.parameters(newParameters);\n        return this;\n    }\n    /**\n     * Returns true when an attempt to `reload` the current `parameter` values have resulted in a failure.\n     * This method will continue to return true until the `reload` is successfully called or when the\n     * `parameter` values have changed\n     */\n    hasErrorState() {\n        return !!(this.errParamsMemento && ng1.equals(this.errParamsMemento, this.createComparableParams()));\n    }\n    /**\n     * Returns true if `filter` has significant filter value(s) (any value except null, undefined, or empty string),\n     * otherwise false\n     */\n    hasFilter() {\n        return Object.keys(this.filter(true)).length > 0;\n    }\n    /**\n     * Return true when a change to `filters` require the `reload` method\n     * to be run so as to ensure the data presented to the user reflects these filters\n     */\n    hasFilterChanges() {\n        const previousFilter = (this.prevParamsMemento && this.prevParamsMemento.params.filter);\n        return !ng1.equals((this._params.filter), previousFilter) || this.hasGlobalSearchFieldChanges();\n    }\n    /**\n     * Returns true when at least one group has been set\n     */\n    hasGroup(): boolean\n    /**\n     * Returns true when the `group` and when supplied, the `sortDirection` matches an existing group\n     */\n    hasGroup(group: string | IGroupingFunc<T>, sortDirection?: string): boolean\n    hasGroup(group?: string | IGroupingFunc<T>, sortDirection?: string) {\n        if (group == null) {\n            return isGroupingFun(this._params.group) || Object.keys(this._params.group).length > 0\n        }\n\n        if (isGroupingFun(group)) {\n            if (sortDirection == null) {\n                return this._params.group === group;\n            } else {\n                return this._params.group === group && group.sortDirection === sortDirection;\n            }\n        } else {\n            if (sortDirection == null) {\n                return Object.keys(this._params.group).indexOf(group) !== -1;\n            } else {\n                return (this._params.group as IGroupValues)[group] === sortDirection;\n            }\n        }\n    }\n    /**\n     * Return true when a change to this instance should require the `reload` method\n     * to be run so as to ensure the data rows presented to the user reflects the current state.\n     *\n     * Note that this method will return false when the `reload` method has run but fails. In this case\n     * `hasErrorState` will return true.\n     *\n     * The built-in `ngTable` directives will watch for when this function returns true and will then call\n     * the `reload` method to load its data rows\n     */\n    isDataReloadRequired() {\n        // note: using != as want to treat null and undefined the same\n        return !this.isCommittedDataset || !ng1.equals(this.createComparableParams(), this.prevParamsMemento)\n            || this.hasGlobalSearchFieldChanges();\n    }\n    /**\n     * Returns true if sorting by the field supplied. Where direction supplied\n     * the field must also be sorted by that direction to return true\n     */\n    isSortBy(field: string, direction?: string) {\n        if (direction !== undefined) {\n            return this._params.sorting[field] !== undefined && this._params.sorting[field] == direction;\n        } else {\n            return this._params.sorting[field] !== undefined;\n        }\n    }\n    /**\n     * Returns sorting values in a format that can be consumed by the angular `$orderBy` filter service\n     */\n    orderBy() {\n        return convertSortToOrderBy(this._params.sorting);\n    }\n    /**\n     * Returns the index of the current \"slice\" of data rows\n     */\n    page(): number\n    /**\n     * Sets the index of the current \"slice\" of data rows. The index starts at 1.\n     * Changing the page number will cause `isDataReloadRequired` to return true\n     */\n    page(page: number): this\n    page(page?: number) {\n        return page !== undefined ? this.parameters({\n            'page': page\n        }) : this._params.page;\n    }\n    parameters(): IParamValues<T>\n    /**\n     * Set new parameters\n     */\n    parameters(newParameters?: IParamValues<T> | { [name: string]: string }, parseParamsFromUrl?: boolean): this\n    parameters(newParameters?: IParamValues<T> | { [name: string]: string }, parseParamsFromUrl?: boolean): IParamValues<T> | this {\n        parseParamsFromUrl = parseParamsFromUrl || false;\n        if (typeof newParameters !== undefined) {\n            for (const key in newParameters) {\n                let value = newParameters[key];\n                if (parseParamsFromUrl && key.indexOf('[') >= 0) {\n                    const keys = key.split(/\\[(.*)\\]/).reverse()\n                    let lastKey = '';\n                    for (let i = 0, len = keys.length; i < len; i++) {\n                        const name = keys[i];\n                        if (name !== '') {\n                            const v = value;\n                            value = {};\n                            value[lastKey = name] = (isNumber(v) ? parseFloat(v) : v);\n                        }\n                    }\n                    if (lastKey === 'sorting') {\n                        this._params[lastKey] = {};\n                    }\n                    this._params[lastKey] = ng1.extend(this._params[lastKey] || {}, value[lastKey]);\n                } else {\n                    if (key === 'group') {\n                        this._params[key] = this.parseGroup(newParameters[key]);\n                    } else {\n                        this._params[key] = (isNumber(newParameters[key]) ? parseFloat(newParameters[key]) : newParameters[key]);\n                    }\n                }\n            }\n            this.log('ngTable: set parameters', this._params);\n            return this;\n        }\n        return this._params;\n    }\n    /**\n     * Trigger a reload of the data rows\n     */\n    reload<TResult extends DataResult<T>>(): IPromise<TResult[]> {\n        let pData: ng1.IPromise<any> = null;\n\n        this._settings.$loading = true;\n\n        this.prevParamsMemento = ng1.copy(this.createComparableParams());\n        this.isCommittedDataset = true;\n\n        if (this.hasGroup()) {\n            pData = this.runInterceptorPipeline(NgTableParams.$q.when(this._settings.getGroups(this)));\n        } else {\n            const fn = this._settings.getData as IGetDataFunc<T>;\n            pData = this.runInterceptorPipeline(NgTableParams.$q.when(fn(this)));\n        }\n\n        this.log('ngTable: reload data');\n\n        const oldData = this.data;\n        return pData.then(data => {\n            this._settings.$loading = false;\n            this.errParamsMemento = null;\n\n            this.data = data;\n            // note: I think it makes sense to publish this event even when data === oldData\n            // subscribers can always set a filter to only receive the event when data !== oldData\n            NgTableParams.ngTableEventsChannel.publishAfterReloadData(this, data, oldData);\n            this.reloadPages();\n\n            return data;\n        }).catch(reason => {\n            this.errParamsMemento = this.prevParamsMemento;\n            // \"rethrow\"\n            return NgTableParams.$q.reject(reason);\n        });\n    }\n    /**\n     * Returns the settings for the table.\n     */\n    settings(): ISettings<T>\n    /**\n     * Sets the settings for the table; new setting values will be merged with the existing settings.\n     * Supplying a new `dataset` will cause `isDataReloadRequired` to return true and the `ngTableEventsChannel`\n     * to fire its `datasetChanged` event\n     */\n    settings(newSettings: ISettings<T>): this\n    settings(newSettings?: ISettings<T>): this | ISettings<T> {\n        if (ng1.isDefined(newSettings)) {\n\n            const settings = NgTableParams.ngTableSettings.merge(this._settings, newSettings);\n\n            const originalDataset = this._settings.dataset;\n            this._settings = settings;\n\n            // note: using != as want null and undefined to be treated the same\n            const hasDatasetChanged = newSettings.hasOwnProperty('dataset') && (newSettings.dataset != originalDataset);\n            if (hasDatasetChanged) {\n                if (this.isCommittedDataset) {\n                    this.page(1); // reset page as a new dataset has been supplied\n                }\n                this.isCommittedDataset = false;\n\n                const fireEvent = () => {\n                    NgTableParams.ngTableEventsChannel.publishDatasetChanged(this, newSettings.dataset, originalDataset);\n                };\n\n                if (this.initialEvents) {\n                    this.initialEvents.push(fireEvent);\n                } else {\n                    fireEvent();\n                }\n            }\n            this.log('ngTable: set settings', this._settings);\n            return this;\n        }\n        return this._settings;\n    }\n    /**\n     * Returns the current sorting used to order the data rows.\n     * Changes to sorting will cause `isDataReloadRequired` to return true\n     */\n    sorting(): ISortingValues\n    /**\n     * Sets sorting values to the `sorting` supplied; any existing sorting will be removed.\n     * Changes to sorting will cause `isDataReloadRequired` to return true\n     */\n    sorting(sorting: ISortingValues): this\n    /**\n     * Sets sorting to the `field` and `direction` supplied; any existing sorting will be removed\n     */\n    sorting(field: string, direction: string): this\n    sorting(sorting?: ISortingValues | string, direction?: SortDirection) {\n        if (typeof sorting === 'string') {\n            this.parameters({\n                'sorting': { [sorting]: direction }\n            });\n            return this;\n        }\n        return sorting !== undefined ? this.parameters({\n            'sorting': sorting\n        }) : this._params.sorting;\n    }\n    /**\n     * Returns the count of the data rows that match the current `filter`\n     */\n    total(): number\n    /**\n     * Sets `settings().total` to the value supplied.\n     * Typically you will need to set a `total` in the body of any custom `getData` function\n     * you supply as a setting value to this instance.\n     * @example\n     * ```js\n     * const tp = new NgTableParams({}, { getData: customGetData })\n     * function customGetData(params) {\n     *      const queryResult = // code to fetch current data rows and total //\n     *      params.total(queryResult.total);\n     *      return queryResult.dataRowsPage;\n     * }\n     * ```\n     */\n    total(total: number): this\n    total(total?: number) {\n        return total !== undefined ? this.settings({\n            'total': total\n        }) : this._settings.total;\n    }\n    /**\n     * Returns the current parameter values uri-encoded. Set `asString` to\n     * true for the parameters to be returned as an array of strings of the form 'paramName=value'\n     * otherwise parameters returned as a key-value object\n     */\n    url(asString?: boolean) {\n        // this function is an example of Typescript gone bad!!\n        asString = asString || false;\n        const pairs: any[] | { [name: string]: string } = (asString ? [] : {});\n        for (const key in this._params) {\n            if (this._params.hasOwnProperty(key)) {\n                const item = (this._params as { [name: string]: any })[key],\n                    name = encodeURIComponent(key);\n                if (typeof item === \"object\") {\n                    for (const subkey in item) {\n                        if (isSignificantValue(item[subkey], key)) {\n                            const pname = name + \"[\" + encodeURIComponent(subkey) + \"]\";\n                            collectValue(item[subkey], pname);\n                        }\n                    }\n                } else if (!ng1.isFunction(item) && isSignificantValue(item, key)) {\n                    collectValue(item, name);\n                }\n            }\n        }\n        return pairs;\n\n        function collectValue(value: any, key: string) {\n            if (isArray(pairs)) {\n                pairs.push(key + \"=\" + encodeURIComponent(value));\n            } else {\n                pairs[key] = encodeURIComponent(value);\n            }\n        }\n\n        function isArray(pairs: any[] | {}): pairs is Array<any> {\n            return asString;\n        }\n\n        function isSignificantValue(value: any, key: string) {\n            return key === \"group\" ? true : typeof value !== undefined && value !== \"\";\n        }\n    }\n    private createComparableParams(): Memento<T> {\n        const group = this._params.group;\n        return {\n            params: this._params,\n            groupSortDirection: isGroupingFun(group) ? group.sortDirection : undefined\n        };\n    }\n    private hasGlobalSearchFieldChanges() {\n        const currentVal = (this._params.filter && this._params.filter['$']);\n        const previousVal =\n            (this.prevParamsMemento && this.prevParamsMemento.params.filter && this.prevParamsMemento.params.filter['$']);\n        return !ng1.equals(currentVal, previousVal);\n    }\n    private log(...args: any[]) {\n        if (this._settings.debugMode && NgTableParams.$log.debug) {\n            NgTableParams.$log.debug(...args);\n        }\n    }\n    private parseGroup(group: string | Grouping<T>) {\n        const defaultSort = this._settings.groupOptions && this._settings.groupOptions.defaultSort;\n        if (!group) {\n            return group;\n        } else if (isGroupingFun(group)) {\n            if (group.sortDirection == null) {\n                group.sortDirection = defaultSort;\n            }\n            return group;\n        } else if (typeof group === 'object') {\n            for (const key in group) {\n                if (group[key] == null) {\n                    group[key] = defaultSort;\n                }\n            }\n            return group;\n        } else {\n            return {\n                [group]: defaultSort\n            };\n        }\n    }\n    private runInterceptorPipeline(fetchedData: ng1.IPromise<any>) {\n        const interceptors = this._settings.interceptors || [];\n\n        return interceptors.reduce((result, interceptor) => {\n            const thenFn = (interceptor.response && interceptor.response.bind(interceptor)) || NgTableParams.$q.when;\n            const rejectFn = (interceptor.responseError && interceptor.responseError.bind(interceptor)) || NgTableParams.$q.reject;\n            return result.then(data => {\n                return thenFn(data, this);\n            }, reason => {\n                return rejectFn(reason, this);\n            });\n        }, fetchedData);\n    }\n\n    private static $q: ng1.IQService;\n    private static $log: ng1.ILogService;\n    private static ngTableDefaults: IDefaults;\n    private static ngTableEventsChannel: NgTableEventsChannel;\n    private static ngTableSettings: NgTableSettings;\n    static init(\n        $q: ng1.IQService,\n        $log: ng1.ILogService,\n        ngTableDefaults: IDefaults,\n        ngTableEventsChannel: NgTableEventsChannel,\n        ngTableSettings: NgTableSettings) {\n        NgTableParams.$q = $q;\n        NgTableParams.$log = $log;\n        NgTableParams.ngTableDefaults = ngTableDefaults;\n        NgTableParams.ngTableEventsChannel = ngTableEventsChannel;\n        NgTableParams.ngTableSettings = ngTableSettings;\n    }\n}\n\nNgTableParams.init.$inject = ['$q', '$log', 'ngTableDefaults', 'ngTableEventsChannel', 'ngTableSettings'];\n\n\n// WEBPACK FOOTER //\n// ./~/angular1-template-loader!./src/core/ngTableParams.ts","import * as ng1 from 'angular';\nimport { IPromise } from 'angular';\nimport { IDefaults } from './ngTableDefaults';\nimport { IDataRowGroup, IDataSettings, IDefaultGetData, IGetDataFunc, IInterceptor, IInterceptableGetDataFunc } from './data';\nimport { IFilterValues, IFilterSettings } from './filtering';\nimport { IGetGroupFunc, IGroupSettings } from './grouping';\nimport { SortDirection } from './sorting';\nimport { NgTableParams } from './ngTableParams';\n\n/**\n * Configuration settings for {@link NgTableParams}\n */\nexport interface ISettings<T> {\n    /**\n     * Returns true whenever a call to `getData` is in progress\n     */\n    $loading?: boolean;\n    /**\n     * An array that contains all the data rows that table should manage.\n     * The `gateData` function will be used to manage the data rows\n     * that ultimately will be displayed.\n     */\n    dataset?: T[];\n    dataOptions?: IDataSettings;\n    debugMode?: boolean;\n    /**\n     * The total number of data rows before paging has been applied.\n     * Typically you will not need to supply this yourself\n     */\n    total?: number;\n    /**\n     * The default sort direction that will be used whenever a sorting is supplied that\n     * does not define its own sort direction\n     */\n    defaultSort?: SortDirection;\n    filterOptions?: IFilterSettings<T>;\n    groupOptions?: IGroupSettings;\n    /**\n     * The page size buttons that should be displayed. Each value defined in the array\n     * determines the possible values that can be supplied to {@link NgTableParams} `page`\n     */\n    counts?: number[];\n    /**\n     * The collection of interceptors that should apply to the results of a call to\n     * the `getData` function before the data rows are displayed in the table\n     */\n    interceptors?: IInterceptor<T>[];\n    /**\n     * Configuration for the template that will display the page size buttons\n     */\n    paginationMaxBlocks?: number;\n    /**\n     * Configuration for the template that will display the page size buttons\n     */\n    paginationMinBlocks?: number;\n    /**\n     * The html tag that will be used to display the sorting indicator in the table header\n     */\n    sortingIndicator?: string;\n    /**\n     * The function that will be used fetch data rows. Leave undefined to let the {@link IDefaultGetData}\n     * service provide a default implementation that will work with the `dataset` array you supply.\n     *\n     * Typically you will supply a custom function when you need to execute filtering, paging and sorting\n     * on the server\n     */\n    getData?: IGetDataFunc<T> | IInterceptableGetDataFunc<T>;\n    /**\n     * The function that will be used group data rows according to the groupings returned by {@link NgTableParams} `group`\n    */\n    getGroups?: IGetGroupFunc<T>;\n}\n\n/**\n * @private\n */\nexport class NgTableSettings {\n    static $inject = ['ngTableDefaults', 'ngTableDefaultGetData', 'ngTableDefaultGetGroups'];\n    private defaults: ISettings<any>;\n    constructor(\n        private ngTableDefaults: IDefaults,\n        private ngTableDefaultGetData: IDefaultGetData<any>,\n        private ngTableDefaultGetGroups: IGetGroupFunc<any>) {\n\n        this.defaults = {\n            $loading: false,\n            dataset: null, //allows data to be set when table is initialized\n            total: 0,\n            defaultSort: 'desc',\n            counts: [10, 25, 50, 100],\n            filterOptions: {\n                filterComparator: undefined, // look for a substring match in case insensitive way\n                filterDelay: 500,\n                filterDelayThreshold: 10000, // size of dataset array that will trigger the filterDelay being applied\n                filterFilterName: undefined, // when defined overrides ngTableDefaultGetDataProvider.filterFilterName\n                filterFn: undefined, // when defined overrides the filter function that ngTableDefaultGetData uses\n                filterLayout: 'stack'\n            },\n            getData: (params: NgTableParams<any>) => {\n                return this.ngTableDefaultGetData(params.settings().dataset, params);\n            },\n            getGroups: this.ngTableDefaultGetGroups,\n            groupOptions: {\n                defaultSort: 'asc', // set to 'asc' or 'desc' to apply sorting to groups\n                isExpanded: true\n            },\n            interceptors: [],\n            paginationMaxBlocks: 11,\n            paginationMinBlocks: 5,\n            sortingIndicator: 'span'\n        };\n    }\n    createDefaults<T>(): ISettings<T> {\n        return this.merge(this.defaults, this.ngTableDefaults.settings);\n    }\n    merge<T>(existing: ISettings<T>, newSettings: ISettings<T>): ISettings<T> {\n\n        newSettings = ng1.extend({}, newSettings);\n\n        if (newSettings.filterOptions) {\n            newSettings.filterOptions = ng1.extend({}, existing.filterOptions || {}, newSettings.filterOptions);\n        }\n        if (newSettings.groupOptions) {\n            newSettings.groupOptions = ng1.extend({}, existing.groupOptions || {}, newSettings.groupOptions);\n        }\n\n        if (ng1.isArray(newSettings.dataset)) {\n            //auto-set the total from passed in dataset\n            newSettings.total = newSettings.dataset.length;\n        }\n        const results = ng1.extend({}, existing, newSettings);\n        if (ng1.isArray(newSettings.dataset)) {\n            this.optimizeFilterDelay(results);\n        }\n        return ng1.extend({}, existing, newSettings);\n    }\n    private optimizeFilterDelay<T>(settings: ISettings<T>) {\n        // don't debounce by default filter input when working with small synchronous datasets\n        if (settings.filterOptions.filterDelay === this.defaults.filterOptions.filterDelay &&\n            settings.total <= settings.filterOptions.filterDelayThreshold &&\n            settings.getData === this.defaults.getData) {\n            settings.filterOptions.filterDelay = 0;\n        }\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./~/angular1-template-loader!./src/core/ngTableSettings.ts","import { Grouping, IGroupingFunc } from './grouping';\nimport { ISortingValues } from './sorting';\n\n/**\n * @private\n */\nexport function convertSortToOrderBy(sorting: ISortingValues) {\n    const result: string[] = [];\n    for (let column in sorting) {\n        result.push((sorting[column] === \"asc\" ? \"+\" : \"-\") + column);\n    }\n    return result;\n}\n\n/**\n * @private\n */\nexport function isGroupingFun(val: string | Grouping<any>): val is IGroupingFunc<any> {\n    return typeof val === 'function'\n}\n\n\n// WEBPACK FOOTER //\n// ./~/angular1-template-loader!./src/core/util.ts","/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\nimport { IAugmentedJQuery, IDirective, IQService, IParseService, IPromise, IScope } from 'angular';\nimport * as ng1 from 'angular';\nimport { \n    IColumnDef, ColumnFieldContext, IColumnField, IFilterTemplateDefMap, SelectData, ITableInputAttributes \n} from './public-interfaces';\nimport { NgTableController } from './ngTableController';\n\ninterface IScopeExtensions {\n    $columns: IColumnDef[]\n}\n\nngTable.$inject = ['$q', '$parse'];\n\n/**\n * Directive that instantiates {@link NgTableController NgTableController}.\n * @ngdoc directive\n * @name ngTable\n * @example\n * \n * ```html\n * <table ng-table=\"$ctrl.tableParams\" show-filter=\"true\" class=\"table table-bordered\">\n *  <tr ng-repeat=\"user in $data\">\n *      <td data-title=\"'Name'\" sortable=\"'name'\" filter=\"{ 'name': 'text' }\">\n *          {{user.name}}\n *      </td>\n *      <td data-title=\"'Age'\" sortable=\"'age'\" filter=\"{ 'age': 'text' }\">\n *          {{user.age}}\n *      </td>\n *  </tr>\n * </table>\n * ```\n */\nexport function ngTable($q: IQService, $parse: IParseService) : IDirective {\n\n    return {\n        restrict: 'A',\n        priority: 1001,\n        scope: true,\n        controller: 'ngTableController',\n        compile: function(element: IAugmentedJQuery) {\n            let columns: IColumnDef[] = [],\n                i = 0,\n                dataRow: JQuery,\n                groupRow: JQuery\n            const rows: JQuery[] = [];\n\n            ng1.forEach(element.find('tr'), (tr: JQuery) => {\n                rows.push(ng1.element(tr))\n            });\n            dataRow = rows.filter(tr => !tr.hasClass('ng-table-group'))[0];\n            groupRow = rows.filter(tr => tr.hasClass('ng-table-group'))[0];\n\n            if (!dataRow) {\n                return undefined;\n            }\n            ng1.forEach(dataRow.find('td'), (item: JQuery) => {\n                const el = ng1.element(item);\n                if (el.attr('ignore-cell') && 'true' === el.attr('ignore-cell')) {\n                    return;\n                }\n\n                const getAttrValue = function(attr: string){\n                    return el.attr('x-data-' + attr) || el.attr('data-' + attr) || el.attr(attr);\n                };\n                const setAttrValue = function(attr: string, value: string){\n                    if (el.attr('x-data-' + attr)){\n                        el.attr('x-data-' + attr, value)\n                    } else if (el.attr('data' + attr)){\n                        el.attr('data' + attr, value)\n                    } else {\n                        el.attr(attr, value)\n                    }\n                };\n\n                const parsedAttribute = function<T>(attr: string): IColumnField<T> {\n                    const expr = getAttrValue(attr);\n                    if (!expr){\n                        return undefined;\n                    }\n\n                    let localValue: any;\n                    const getter = (context: ColumnFieldContext) => {\n                        if (localValue !== undefined){\n                            return localValue as T;\n                        }\n                        return $parse(expr)(context) as T;\n                    };\n                    (getter as any).assign = ($scope: ColumnFieldContext, value: any) => {\n                        const parsedExpr = $parse(expr);\n                        if (parsedExpr.assign) {\n                            // we should be writing back to the parent scope as this is where the expression\n                            // came from\n                            parsedExpr.assign($scope.$parent, value);\n                        } else {\n                            localValue = value;\n                        }\n                    };\n                    return getter as IColumnField<T>;\n                };\n                const titleExpr = getAttrValue('title-alt') || getAttrValue('title');\n                if (titleExpr){\n                    el.attr('data-title-text', '{{' + titleExpr + '}}'); // this used in responsive table\n                }\n                // NOTE TO MAINTAINERS: if you add extra fields to a $column be sure to extend ngTableColumn with\n                // a corresponding \"safe\" default\n                columns.push({\n                    id: i++,\n                    title: parsedAttribute<string>('title'),\n                    titleAlt: parsedAttribute<string>('title-alt'),\n                    headerTitle: parsedAttribute<string>('header-title'),\n                    sortable: parsedAttribute<string | boolean>('sortable'),\n                    'class': parsedAttribute<string>('header-class'),\n                    filter: parsedAttribute<IFilterTemplateDefMap>('filter'),\n                    groupable: parsedAttribute<string | boolean>('groupable'),\n                    headerTemplateURL: parsedAttribute<string | boolean>('header'),\n                    filterData: parsedAttribute<IPromise<SelectData> | SelectData>('filter-data'),\n                    show: el.attr(\"ng-if\") ? parsedAttribute<boolean>('ng-if') : undefined\n                });\n\n                if (groupRow || el.attr(\"ng-if\")){\n                    // change ng-if to bind to our column definition which we know will be writable\n                    // because this will potentially increase the $watch count, only do so if we already have an\n                    // ng-if or when we definitely need to change visibility of the columns.\n                    // currently only ngTableGroupRow directive needs to change visibility\n                    setAttrValue('ng-if', '$columns[' + (columns.length - 1) + '].show(this)');\n                }\n            });\n            return function(scope: IScope & IScopeExtensions, element: IAugmentedJQuery, attrs: ITableInputAttributes, controller: NgTableController<any, IColumnDef>) {\n                scope.$columns = columns = controller.buildColumns(columns);\n\n                controller.setupBindingsToInternalScope(attrs.ngTable);\n                controller.loadFilterData(columns);\n                controller.compileDirectiveTemplates();\n            };\n        }\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./~/angular1-template-loader!./src/browser/ngTable.directive.ts","/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\nimport { IScope } from 'angular';\nimport * as ng1 from 'angular';\nimport { IColumnDef, IDynamicTableColDef } from './public-interfaces';\n\n/**\n * @private\n */\nfunction isScopeLike(object: any) {\n    return object != null && ng1.isFunction(object.$new);\n}\n\n/**\n * @private\n * Service to construct a $column definition used by {@link ngTable ngTable} directive\n */\nexport class NgTableColumn<TCol extends IColumnDef | IDynamicTableColDef> {\n    static $inject: string[] = [];\n\n    /**\n     * Creates a $column for use within a header template\n     *\n     * @param column the initial definition for $column to build\n     * @param defaultScope the $scope to supply to the $column getter methods when not supplied by caller\n     * @param columns a reference to the $columns array to make available on the context supplied to the\n     * $column getter methods\n     */\n    buildColumn(column: TCol, defaultScope: IScope, columns: IColumnDef[]): IColumnDef {\n        // note: we're not modifying the original column object. This helps to avoid unintended side affects\n        const extendedCol = Object.create(column);\n        const defaults = this.createDefaults();\n        for (const prop in defaults) {\n            if (extendedCol[prop] === undefined) {\n                extendedCol[prop] = defaults[prop];\n            }\n            if (!ng1.isFunction(extendedCol[prop])) {\n                // wrap raw field values with \"getter\" functions\n                // - this is to ensure consistency with how ngTable.compile builds columns\n                // - note that the original column object is being \"proxied\"; this is important\n                //   as it ensure that any changes to the original object will be returned by the \"getter\"\n                const getterSetter = function getterSetter(/*[value] || [$scope, locals]*/) {\n                    if (arguments.length === 1 && !isScopeLike(arguments[0])) {\n                        (getterSetter as any).assign(null, arguments[0]);\n                    } else {\n                        return column[prop];\n                    }\n                };\n                (getterSetter as any).assign = function ($scope: IScope, value: any) {\n                    column[prop] = value;\n                };\n                extendedCol[prop] = getterSetter;\n            }\n            // satisfy the arguments expected by the function returned by parsedAttribute in the ngTable directive\n            const getterFn = extendedCol[prop];\n            extendedCol[prop] = function () {\n                if (arguments.length === 1 && !isScopeLike(arguments[0])) {\n                    getterFn.assign(defaultScope, arguments[0]);\n                } else {\n                    const scope = arguments[0] || defaultScope;\n                    const context = Object.create(scope);\n                    ng1.extend(context, {\n                        $column: extendedCol,\n                        $columns: columns\n                    });\n                    return getterFn.call(column, context);\n                }\n            };\n            if (getterFn.assign) {\n                extendedCol[prop].assign = getterFn.assign;\n            } else {\n                const wrappedGetterFn = extendedCol[prop];\n                let localValue: any;\n                const getterSetter = function getterSetter(/*[value] || [$scope, locals]*/) {\n                    if (arguments.length === 1 && !isScopeLike(arguments[0])) {\n                        (getterSetter as any).assign(null, arguments[0]);\n                    } else {\n                        return localValue != undefined ? localValue : wrappedGetterFn.apply(extendedCol, arguments);\n                    }\n                };\n                (getterSetter as any).assign = function ($scope: IScope, value: any) {\n                    localValue = value;\n                };\n                extendedCol[prop] = getterSetter;\n            }\n        }\n        return extendedCol as IColumnDef;\n    }\n\n    private createDefaults() {\n        return {\n            'class': this.createGetterSetter(''),\n            filter: this.createGetterSetter(false),\n            groupable: this.createGetterSetter(false),\n            filterData: ng1.noop,\n            headerTemplateURL: this.createGetterSetter(false),\n            headerTitle: this.createGetterSetter(''),\n            sortable: this.createGetterSetter(false),\n            show: this.createGetterSetter(true),\n            title: this.createGetterSetter(''),\n            titleAlt: this.createGetterSetter('')\n        };\n    }\n\n    private createGetterSetter(initialValue: any) {\n        let value = initialValue;\n        const getterSetter = function getterSetter(/*[value] || [$scope, locals]*/) {\n            if (arguments.length === 1 && !isScopeLike(arguments[0])) {\n                (getterSetter as any).assign(null, arguments[0]);\n            } else {\n                return value;\n            }\n        };\n        (getterSetter as any).assign = function ($scope: IScope, newValue: any) {\n            value = newValue;\n        };\n        return getterSetter;\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./~/angular1-template-loader!./src/browser/ngTableColumn.ts","/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\nimport { IAugmentedJQuery, IAttributes, IDirective, IParseService } from 'angular';\nimport { ITableScope } from './ngTableController';\nimport { IColumnDef } from './public-interfaces';\n\n/**\n * @private\n */\ninterface IInputAttributes extends IAttributes {\n    ngTableColumnsBinding: string;\n}\n\nngTableColumnsBinding.$inject = [\"$parse\"];\n\n/**\n * One-way data binds the $columns array generated by ngTable/ngTableDynamic to the specified\n * expression.\n * This allows the $columns array created for the table to be accessed outside of the html table\n * markup.\n * \n * @ngdoc directive\n * \n * @example\n * ```html\n * <table ng-table=\"$ctrl.tableParams\" class=\"table\" ng-table-columns-binding=\"$ctlr.tableColumns\">\n * ```\n */\nexport function ngTableColumnsBinding<T>($parse: IParseService) : IDirective {\n    const directive = {\n        restrict: 'A',\n        link: linkFn\n    };\n    return directive;\n\n    function linkFn($scope: ITableScope<T>, $element: IAugmentedJQuery, $attrs: IInputAttributes){\n        const setter = $parse($attrs.ngTableColumnsBinding).assign;\n        if (setter){\n            $scope.$watch<IColumnDef[]>('$columns', newColumns => {\n                const shallowClone = (newColumns || []).slice(0);\n                setter($scope, shallowClone);\n            });\n        }\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./~/angular1-template-loader!./src/browser/ngTableColumnsBinding.directive.ts","/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\nimport {\n    IAttributes, IAugmentedJQuery, ICompileService, IDocumentService, IParseService, IPromise, IScope,\n    ITimeoutService\n} from 'angular';\nimport * as ng1 from 'angular';\nimport {\n    DataResult, DataResults, IDataRowGroup, GroupedDataResults, NgTableParams, NgTableEventsChannel,\n    IPageButton\n} from '../core';\nimport { IColumnDef, IDynamicTableColDef, SelectData, ITableInputAttributes } from './public-interfaces';\nimport { NgTableColumn } from './ngTableColumn';\n\n/**\n * @private\n */\nexport interface ITableScope<T> extends IScope {\n    $columns: IColumnDef[];\n    $loading: boolean;\n    $filterRow: {\n        disabled: boolean;\n    };\n    $data?: DataResults<T>;\n    $groups?: GroupedDataResults<T>;\n    $groupRow: {\n        show: boolean;\n    };\n    show_filter: boolean;\n    pages: IPageButton[];\n    templates: {\n        header: string;\n        pagination: string;\n    },\n    params: NgTableParams<T>\n}\n\n/**\n * The controller for the {@link ngTable ngTable} and {@link ngTableDynamic ngTableDynamic} directives\n */\nexport class NgTableController<TParams, TCol extends IColumnDef | IDynamicTableColDef> {\n    static $inject = [\n        '$scope', '$timeout', '$parse', '$compile', '$attrs', '$element', '$document', 'ngTableColumn', 'ngTableEventsChannel'\n    ];\n    private delayFilter: (callback: () => void, ms: number) => void;\n    private get hasVisibleFilterColumn() {\n        if (!this.$scope.$columns) return false;\n\n        return this.some(this.$scope.$columns, ($column) => {\n            return $column.show(this.$scope) && !!$column.filter(this.$scope);\n        });\n    }\n    constructor(\n        private $scope: ITableScope<TParams>,\n        $timeout: ITimeoutService,\n        private $parse: IParseService,\n        private $compile: ICompileService,\n        private $attrs: IAttributes & ITableInputAttributes,\n        private $element: IAugmentedJQuery,\n        private $document: IDocumentService,\n        private ngTableColumn: NgTableColumn<TCol>,\n        private ngTableEventsChannel: NgTableEventsChannel) {\n\n        const isFirstTimeLoad = true;\n        $scope.$filterRow = { disabled: false };\n        $scope.$loading = false;\n\n        // until such times as the directive uses an isolated scope, we need to ensure that the check for\n        // the params field only consults the \"own properties\" of the $scope. This is to avoid seeing the params\n        // field on a $scope higher up in the prototype chain\n        if (!$scope.hasOwnProperty(\"params\")) {\n            $scope.params = new NgTableParams<TParams>(true);\n        }\n\n        this.delayFilter = (function () {\n            let timer: IPromise<any>;\n            return (callback: () => void, ms: number) => {\n                $timeout.cancel(timer);\n                timer = $timeout(callback, ms);\n            };\n        })();\n\n        // watch for when a new NgTableParams is bound to the scope\n        // CRITICAL: the watch must be for reference and NOT value equality; this is because NgTableParams maintains\n        // the current data page as a field. Checking this for value equality would be terrible for performance\n        // and potentially cause an error if the items in that array has circular references\n        this.$scope.$watch<NgTableParams<TParams>>('params', (newParams, oldParams) => {\n            if (newParams === oldParams || !newParams) {\n                return;\n            }\n\n            newParams.reload();\n        }, false);\n\n        this.subscribeToTableEvents();\n    }\n\n    private onDataReloadStatusChange(newStatus: boolean/*, oldStatus*/) {\n        if (!newStatus || this.$scope.params.hasErrorState()) {\n            return;\n        }\n\n        const currentParams = this.$scope.params;\n        const filterOptions = currentParams.settings().filterOptions;\n\n        if (currentParams.hasFilterChanges()) {\n            const applyFilter = () => {\n                currentParams.page(1);\n                currentParams.reload();\n            };\n            if (filterOptions.filterDelay) {\n                this.delayFilter(applyFilter, filterOptions.filterDelay);\n            } else {\n                applyFilter();\n            }\n        } else {\n            currentParams.reload();\n        }\n    }\n\n    compileDirectiveTemplates() {\n        if (!this.$element.hasClass('ng-table')) {\n            this.$scope.templates = {\n                header: (this.$attrs.templateHeader ? this.$attrs.templateHeader : 'ng-table/header.html'),\n                pagination: (this.$attrs.templatePagination ? this.$attrs.templatePagination : 'ng-table/pager.html')\n            };\n            this.$element.addClass('ng-table');\n            let headerTemplate: IAugmentedJQuery = null;\n\n            // $element.find('> thead').length === 0 doesn't work on jqlite\n            let theadFound = false;\n            ng1.forEach(this.$element.children(), (e) => {\n                if (e.tagName === 'THEAD') {\n                    theadFound = true;\n                }\n            });\n            if (!theadFound) {\n                headerTemplate = ng1.element('<thead ng-include=\"templates.header\"></thead>', this.$document);\n                this.$element.prepend(headerTemplate);\n            }\n            const paginationTemplate = ng1.element(\n                '<div ng-table-pagination=\"params\" template-url=\"templates.pagination\"></div>',\n                this.$document\n            );\n            this.$element.after(paginationTemplate);\n            if (headerTemplate) {\n                this.$compile(headerTemplate)(this.$scope);\n            }\n            this.$compile(paginationTemplate)(this.$scope);\n        }\n    }\n\n    loadFilterData($columns: IColumnDef[]) {\n        ng1.forEach($columns, ($column) => {\n            const result = $column.filterData(this.$scope);\n            if (!result) {\n                delete $column.filterData;\n                return undefined;\n            }\n\n            if (isPromiseLike(result)) {\n                delete $column.filterData;\n                return result.then(data => {\n                    // our deferred can eventually return arrays, functions and objects\n                    if (!ng1.isArray(data) && !ng1.isFunction(data) && !ng1.isObject(data)) {\n                        // if none of the above was found - we just want an empty array\n                        data = [];\n                    }\n                    $column.data = data;\n                });\n            }\n            // otherwise, we just return what the user gave us. It could be a function, array, object, whatever\n            else {\n                return $column.data = result;\n            }\n        });\n\n        function isPromiseLike(val: any): val is IPromise<SelectData> {\n            return val && typeof val === 'object' && typeof val.then === 'function';\n        }\n    }\n\n    buildColumns(columns: TCol[]): IColumnDef[] {\n        // todo: use strictNullChecks and remove guard clause\n        const result: IColumnDef[] = [];\n        (columns || []).forEach(col => {\n            result.push(this.ngTableColumn.buildColumn(col, this.$scope, result));\n        });\n        return result\n    }\n\n    parseNgTableDynamicExpr(attr: string) {\n        if (!attr || attr.indexOf(\" with \") > -1) {\n            const parts = attr.split(/\\s+with\\s+/);\n            return {\n                tableParams: parts[0],\n                columns: parts[1]\n            };\n        } else {\n            throw new Error('Parse error (expected example: ng-table-dynamic=\\'tableParams with cols\\')');\n        }\n    }\n\n    setupBindingsToInternalScope(tableParamsExpr: string) {\n\n        // note: this we're setting up watches to simulate angular's isolated scope bindings\n\n        // note: is REALLY important to watch for a change to the ngTableParams *reference* rather than\n        // $watch for value equivalence. This is because ngTableParams references the current page of data as\n        // a field and it's important not to watch this\n        this.$scope.$watch<NgTableParams<TParams>>(tableParamsExpr, (params) => {\n            if (params === undefined) {\n                return;\n            }\n            this.$scope.params = params;\n        }, false);\n\n        this.setupFilterRowBindingsToInternalScope();\n        this.setupGroupRowBindingsToInternalScope();\n    }\n\n    private setupFilterRowBindingsToInternalScope() {\n        if (this.$attrs.showFilter) {\n            this.$scope.$parent.$watch<boolean>(this.$attrs.showFilter, (value) => {\n                this.$scope.show_filter = value;\n            });\n        } else {\n            this.$scope.$watch(() => this.hasVisibleFilterColumn, (value) => {\n                this.$scope.show_filter = value;\n            })\n        }\n\n        if (this.$attrs.disableFilter) {\n            this.$scope.$parent.$watch<boolean>(this.$attrs.disableFilter, (value) => {\n                this.$scope.$filterRow.disabled = value;\n            });\n        }\n    }\n\n    private setupGroupRowBindingsToInternalScope() {\n        this.$scope.$groupRow = { show: false };\n        if (this.$attrs.showGroup) {\n            const showGroupGetter = this.$parse(this.$attrs.showGroup);\n            this.$scope.$parent.$watch<boolean>(showGroupGetter, (value) => {\n                this.$scope.$groupRow.show = value;\n            });\n            if (showGroupGetter.assign) {\n                // setup two-way databinding thus allowing ngTableGrowRow to assign to the showGroup expression\n                this.$scope.$watch<boolean>('$groupRow.show', (value) => {\n                    showGroupGetter.assign(this.$scope.$parent, value);\n                });\n            }\n        } else {\n            this.$scope.$watch<boolean>('params.hasGroup()', (newValue) => {\n                this.$scope.$groupRow.show = newValue;\n            });\n        }\n    }\n\n    private getVisibleColumns() {\n        return (this.$scope.$columns || []).filter((c) => {\n            return c.show(this.$scope);\n        });\n    }\n\n    private subscribeToTableEvents() {\n\n        this.$scope.$watch('params.isDataReloadRequired()', (newStatus: boolean/*, oldStatus*/) => {\n            this.onDataReloadStatusChange(newStatus);\n        });\n\n        this.ngTableEventsChannel.onAfterReloadData<TParams>(\n            (params, newDatapage) => {\n                const visibleColumns = this.getVisibleColumns();\n                if (params.hasGroup()) {\n                    this.$scope.$groups = (newDatapage || []) as GroupedDataResults<TParams>;\n                    this.$scope.$groups.visibleColumnCount = visibleColumns.length;\n                } else {\n                    this.$scope.$data = (newDatapage || []) as DataResults<TParams>;\n                    this.$scope.$data.visibleColumnCount = visibleColumns.length;\n                }\n            },\n            this.$scope,\n            (publisher) => this.$scope.params === publisher\n        );\n\n        this.ngTableEventsChannel.onPagesChanged<TParams>(\n            (params, newPages) => {\n                this.$scope.pages = newPages;\n            },\n            this.$scope,\n            (publisher) => this.$scope.params === publisher\n        );\n    }\n\n    private some<T>(array: T[], predicate: (item: T) => boolean) {\n        let found = false;\n        for (let i = 0; i < array.length; i++) {\n            const obj = array[i];\n            if (predicate(obj)) {\n                found = true;\n                break;\n            }\n        }\n        return found;\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./~/angular1-template-loader!./src/browser/ngTableController.ts","/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\nimport { IAugmentedJQuery, IDirective, IScope } from 'angular';\nimport * as ng1 from 'angular';\nimport { IColumnDef, IDynamicTableColDef, ITableInputAttributes } from './public-interfaces';\nimport { NgTableController } from './ngTableController';\n\ninterface IScopeExtensions {\n    $columns: IColumnDef[]\n}\n\nngTableDynamic.$inject = [];\n\n/**\n * A dynamic version of the {@link ngTable ngTable} directive that accepts a dynamic list of columns\n * definitions to render\n * @ngdoc directive\n *\n * @example\n * ```html\n * <table ng-table-dynamic=\"$ctrl.tableParams with $ctrl.cols\" class=\"table\">\n *  <tr ng-repeat=\"row in $data\">\n *    <td ng-repeat=\"col in $columns\">{{row[col.field]}}</td>\n *  </tr>\n * </table>\n * ```\n */\nexport function ngTableDynamic () : IDirective{\n\n    return {\n        restrict: 'A',\n        priority: 1001,\n        scope: true,\n        controller: 'ngTableController',\n        compile: function(tElement: IAugmentedJQuery) {\n            let row: IAugmentedJQuery;\n\n            // IE 8 fix :not(.ng-table-group) selector\n            ng1.forEach(tElement.find('tr'), (tr: JQuery) => {\n                tr = ng1.element(tr);\n                if (!tr.hasClass('ng-table-group') && !row) {\n                    row = tr;\n                }\n            });\n            if (!row) {\n                return undefined;\n            }\n\n            ng1.forEach(row.find('td'), (item: JQuery) => {\n                const el = ng1.element(item);\n                const getAttrValue = (attr: string) => {\n                    return el.attr('x-data-' + attr) || el.attr('data-' + attr) || el.attr(attr);\n                };\n\n                // this used in responsive table\n                const titleExpr = getAttrValue('title');\n                if (!titleExpr){\n                    el.attr('data-title-text', '{{$columns[$index].titleAlt(this) || $columns[$index].title(this)}}');\n                }\n                const showExpr = el.attr('ng-if');\n                if (!showExpr){\n                    el.attr('ng-if', '$columns[$index].show(this)');\n                }\n            });\n            return function (scope: IScope & IScopeExtensions, element: IAugmentedJQuery, attrs: ITableInputAttributes, controller: NgTableController<any, IDynamicTableColDef>) {\n                const expr = controller.parseNgTableDynamicExpr(attrs.ngTableDynamic);\n\n                controller.setupBindingsToInternalScope(expr.tableParams);\n                controller.compileDirectiveTemplates();\n\n                scope.$watchCollection<IDynamicTableColDef[]>(expr.columns, (newCols/*, oldCols*/) => {\n                    scope.$columns = controller.buildColumns(newCols);\n                    controller.loadFilterData(scope.$columns);\n                });\n            };\n        }\n    };\n}\n\n\n// WEBPACK FOOTER //\n// ./~/angular1-template-loader!./src/browser/ngTableDynamic.directive.ts","/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\nimport * as ng1 from 'angular';\nimport { IServiceProvider, auto } from 'angular';\nimport { IFilterConfigValues, IFilterTemplateDef } from './public-interfaces';\n\n/**\n * The angular provider used to configure the behaviour of the `NgTableFilterConfig` service.\n */\nexport class NgTableFilterConfigProvider implements IServiceProvider {\n    static $inject = ['$injector'];\n    $get: () => NgTableFilterConfig;\n    private config: IFilterConfigValues;\n    private defaultConfig: IFilterConfigValues = {\n        defaultBaseUrl: 'ng-table/filters/',\n        defaultExt: '.html',\n        aliasUrls: {}\n    };\n    constructor($injector: auto.IInjectorService) {\n        this.$get = () => {\n            return $injector.instantiate<NgTableFilterConfig>(NgTableFilterConfig, { config: ng1.copy(this.config) });\n        }\n        this.$get.$inject = [];\n        this.resetConfigs();\n    }\n\n    /**\n     * Reset back to factory defaults the config values that `NgTableFilterConfig` service will use\n     */\n    resetConfigs() {\n        this.config = this.defaultConfig;\n    }\n\n    /**\n     * Set the config values used by `NgTableFilterConfig` service\n     */\n    setConfig(customConfig: IFilterConfigValues) {\n        const mergeConfig = ng1.extend({}, this.config, customConfig);\n        mergeConfig.aliasUrls = ng1.extend({}, this.config.aliasUrls, customConfig.aliasUrls);\n        this.config = mergeConfig;\n    }\n}\n\n/**\n * Exposes configuration values and methods used to return the location of the html\n * templates used to render the filter row of an ng-table directive\n */\nexport class NgTableFilterConfig {\n    static $inject = ['config'];\n    constructor(\n        /**\n         * Readonly copy of the final values used to configure the service.\n         */\n        public readonly config: IFilterConfigValues\n    ) { }\n\n    /**\n     * Return the url of the html filter template registered with the alias supplied\n     */\n    getUrlForAlias(aliasName: string, filterKey?: string) {\n        return this.config.aliasUrls[aliasName] || this.config.defaultBaseUrl + aliasName + this.config.defaultExt;\n    }\n    \n    /**\n     * Return the url of the html filter template for the supplied definition and key.\n     * For more information see the documentation for {@link IFilterTemplateMap}\n     */\n    getTemplateUrl(filterDef: string | IFilterTemplateDef, filterKey?: string) {\n        let filterName: string;\n        if (typeof filterDef !== 'string') {\n            filterName = filterDef.id;\n        } else {\n            filterName = filterDef;\n        }\n        if (filterName.indexOf('/') !== -1) {\n            return filterName;\n        }\n\n        return this.getUrlForAlias(filterName, filterKey);\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./~/angular1-template-loader!./src/browser/ngTableFilterConfig.ts","/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\nconst templateUrl = require('./filterRow.html');\n\nngTableFilterRow.$inject = [];\n\n/**\n * directive that renders the filter header row for a table \n * @ngdoc directive\n * @example\n * ```html\n * <ng-table-filter-row></ng-table-filter-row>\n * ```\n */\nexport function ngTableFilterRow(){\n    const directive = {\n        restrict: 'E',\n        replace: true,\n        templateUrl: templateUrl,\n        scope: true,\n        controller: 'ngTableFilterRowController',\n        controllerAs: '$ctrl'\n    };\n    return directive;\n}\n\n\n// WEBPACK FOOTER //\n// ./~/angular1-template-loader!./src/browser/ngTableFilterRow.directive.ts","/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\nimport { IScope } from 'angular';\nimport { IFilterTemplateDef, IFilterTemplateDefMap } from './public-interfaces';\nimport { NgTableFilterConfig } from './ngTableFilterConfig';\n\n/**\n * @private\n */\nexport interface IScopeExtensions {\n    getFilterPlaceholderValue(filterDef: string | IFilterTemplateDef, filterKey?: string): string;\n}\n\n/**\n * Controller for the {@link ngTableFilterRow ngTableFilterRow} directive\n */\nexport class NgTableFilterRowController {\n    static $inject = ['$scope', 'ngTableFilterConfig'];\n    config: NgTableFilterConfig;\n    constructor($scope: IScope & IScopeExtensions, ngTableFilterConfig: NgTableFilterConfig) {\n        this.config = ngTableFilterConfig;\n\n        // todo: stop doing this. Why?\n        // * scope inheritance makes it hard to know how supplies functions\n        // * scope is not a concept in angular 2\n        // make function available to filter templates\n        $scope.getFilterPlaceholderValue = this.getFilterPlaceholderValue.bind(this);\n    }\n\n    getFilterCellCss(filter: IFilterTemplateDefMap, layout: string) {\n        if (layout !== 'horizontal') {\n            return 's12';\n        }\n\n        const size = Object.keys(filter).length;\n        const width = parseInt((12 / size).toString(), 10);\n        return 's' + width;\n    }\n\n    getFilterPlaceholderValue(filterDef: string | IFilterTemplateDef, filterKey?: string) {\n        if (typeof filterDef === 'string') {\n            return '';\n        } else {\n            return filterDef.placeholder;\n        }\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./~/angular1-template-loader!./src/browser/ngTableFilterRowController.ts","/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\nconst templateUrl = require('./groupRow.html');\n\nngTableGroupRow.$inject = [];\n\n/**\n * directive that renders the group header row for a table \n * @ngdoc directive\n * @example\n * ```html\n * <ng-table-group-row></ng-table-group-row>\n * ```\n */\nexport function ngTableGroupRow(){\n    const directive = {\n        restrict: 'E',\n        replace: true,\n        templateUrl: templateUrl,\n        scope: true,\n        controller: 'ngTableGroupRowController',\n        controllerAs: '$ctrl'\n    };\n    return directive;\n}\n\n\n// WEBPACK FOOTER //\n// ./~/angular1-template-loader!./src/browser/ngTableGroupRow.directive.ts","/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\nimport { IPromise } from 'angular';\nimport { DataResult, IGroupingFunc, Grouping, GroupSort } from '../core';\nimport { IColumnDef } from './public-interfaces';\nimport { ITableScope } from './ngTableController';\n\n/**\n * @private\n */\nexport interface IScopeExtensions<T> {\n    $selGroup: IGroupingFunc<any> | string;\n    $selGroupTitle: string;\n}\n\n\n/**\n * Controller for the {@link ngTableGroupRow ngTableGroupRow} directive\n */\nexport class NgTableGroupRowController<T> {\n    static $inject = ['$scope'];\n    private groupFns: Array<IGroupingFunc<any> | IColumnDef> = [];\n    constructor(private $scope: ITableScope<T> & IScopeExtensions<T>) {\n        $scope.$watch<Grouping<any>>('params.group()', (newGrouping) => {\n            this.setGroup(newGrouping);\n        }, true);\n    }\n\n    getGroupables() {\n        const groupableCols = this.$scope.$columns.filter($column => !!$column.groupable(this.$scope));\n        return this.groupFns.concat(groupableCols);\n    }\n\n    getGroupTitle(group: IGroupingFunc<any> | IColumnDef) {\n        return this.isGroupingFunc(group) ? group.title : group.title(this.$scope);\n    }\n\n\n    getVisibleColumns() {\n        return this.$scope.$columns.filter($column => $column.show(this.$scope))\n    }\n\n    groupBy(group: IGroupingFunc<any> | IColumnDef) {\n        if (this.isSelectedGroup(group)) {\n            this.changeSortDirection();\n        } else {\n            if (this.isGroupingFunc(group)) {\n                this.$scope.params.group(group);\n            } else {\n                // it's OK, we know that groupable will return a string\n                // this is guaranteed by getGroupables returning only\n                // columns that return (truthy) strings\n                this.$scope.params.group(group.groupable(this.$scope) as string);\n            }\n        }\n    }\n\n    isSelectedGroup(group: IGroupingFunc<any> | IColumnDef) {\n        if (this.isGroupingFunc(group)) {\n            return group === this.$scope.$selGroup;\n        } else {\n            return group.groupable(this.$scope) === this.$scope.$selGroup;\n        }\n    }\n\n    toggleDetail() {\n        this.$scope.params.settings().groupOptions.isExpanded = !this.$scope.params.settings().groupOptions.isExpanded;\n        return this.$scope.params.reload();\n    }\n\n    private changeSortDirection() {\n        let newDirection: GroupSort;\n        if (this.$scope.params.hasGroup(this.$scope.$selGroup, 'asc')) {\n            newDirection = 'desc';\n        } else if (this.$scope.params.hasGroup(this.$scope.$selGroup, 'desc')) {\n            newDirection = '';\n        } else {\n            newDirection = 'asc';\n        }\n        this.$scope.params.group(this.$scope.$selGroup, newDirection);\n    }\n\n    private findGroupColumn(groupKey: IGroupingFunc<any> | string) {\n        return this.$scope.$columns.filter($column => $column.groupable(this.$scope) === groupKey)[0];\n    }\n\n    private isGroupingFunc(val: IColumnDef | Grouping<any>): val is IGroupingFunc<any> {\n        return typeof val === 'function';\n    }\n\n    private setGroup(grouping: Grouping<any>) {\n        const existingGroupCol = this.findGroupColumn(this.$scope.$selGroup);\n        if (existingGroupCol && existingGroupCol.show.assign) {\n            existingGroupCol.show.assign(this.$scope, true);\n        }\n        if (this.isGroupingFunc(grouping)) {\n            this.groupFns = [grouping];\n            this.$scope.$selGroup = grouping;\n            this.$scope.$selGroupTitle = grouping.title;\n        } else {\n            // note: currently only one group is implemented\n            const groupKey = Object.keys(grouping || {})[0];\n            const groupedColumn = this.findGroupColumn(groupKey);\n            if (groupedColumn) {\n                this.$scope.$selGroupTitle = groupedColumn.title(this.$scope);\n                this.$scope.$selGroup = groupKey;\n                if (groupedColumn.show.assign) {\n                    groupedColumn.show.assign(this.$scope, false);\n                }\n            }\n        }\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./~/angular1-template-loader!./src/browser/ngTableGroupRowController.ts","/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\nimport * as ng1 from 'angular';\nimport { NgTableEventsChannel, IPageButton } from '../core'\nimport { ITableScope } from './ngTableController';\n\ninterface IScopeExtensions {\n    pages: IPageButton[]\n}\n\nngTablePagination.$inject = ['$compile', '$document', 'ngTableEventsChannel'];\n\n/**\n * Directive that renders the table pagination controls\n * @ngdoc directive\n */\nexport function ngTablePagination<T>($compile: ng1.ICompileService, $document: ng1.IDocumentService, ngTableEventsChannel: NgTableEventsChannel): ng1.IDirective {\n\n    return {\n        restrict: 'A',\n        scope: {\n            'params': '=ngTablePagination',\n            'templateUrl': '='\n        },\n        replace: false,\n        link: function(scope: ITableScope<T> & IScopeExtensions, element: ng1.IAugmentedJQuery/*, attrs*/) {\n\n            ngTableEventsChannel.onAfterReloadData<T>(function(pubParams) {\n                scope.pages = pubParams.generatePagesArray();\n            }, scope, function(pubParams){\n                return pubParams === scope.params;\n            });\n\n            scope.$watch<string>('templateUrl', function(templateUrl) {\n                if (templateUrl === undefined) {\n                    return;\n                }\n                const template = ng1.element('<div ng-include=\"templateUrl\"></div>', $document);\n                element.append(template);\n                $compile(template)(scope);\n            });\n        }\n    };\n}\n\n\n// WEBPACK FOOTER //\n// ./~/angular1-template-loader!./src/browser/ngTablePagination.directive.ts","/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\nimport * as ng1 from 'angular';\nimport { IColumnDef, SelectData, ISelectDataFunc, ISelectOption } from './public-interfaces';\n\n/**\n * @private\n */\nexport interface IInputAttributes extends ng1.IAttributes {\n    ngTableSelectFilterDs: string;\n}\n\n/**\n * @private\n */\nexport interface IScopeExtensions {\n    $selectData: ISelectOption[]\n}\n\nngTableSelectFilterDs.$inject = [];\n\n/**\n * Takes the array returned by $column.filterData and makes it available as `$selectData` on the `$scope`.\n *\n * The resulting `$selectData` array will contain an extra item that is suitable to represent the user\n * \"deselecting\" an item from a `<select>` tag\n *\n * This directive is is focused on providing a datasource to an `ngOptions` directive\n */\nfunction ngTableSelectFilterDs(): ng1.IDirective {\n    // note: not using isolated or child scope \"by design\"\n    // this is to allow this directive to be combined with other directives that do\n\n    const directive = {\n        restrict: 'A',\n        controller: NgTableSelectFilterDsController\n    };\n    return directive;\n}\n\n/**\n * @private\n */\nexport class NgTableSelectFilterDsController {\n    static $inject = ['$scope', '$parse', '$attrs', '$q'];\n    $column: IColumnDef;\n    constructor(\n        private $scope: ng1.IScope & IScopeExtensions,\n        $parse: ng1.IParseService,\n        private $attrs: IInputAttributes,\n        private $q: ng1.IQService) {\n\n        this.$column = $parse($attrs.ngTableSelectFilterDs)($scope);\n        $scope.$watch<SelectData>(\n            () => this.$column && this.$column.data,\n            () => { this.bindDataSource(); });\n    }\n    private bindDataSource() {\n        this.getSelectListData(this.$column).then(data => {\n            if (data && !this.hasEmptyOption(data)) {\n                data.unshift({ id: '', title: '' });\n            }\n            data = data || [];\n            this.$scope.$selectData = data;\n        });\n    }\n\n    private hasEmptyOption(data: ISelectOption[]) {\n        let isMatch: boolean;\n        for (let i = 0; i < data.length; i++) {\n            const item = data[i];\n            if (item && item.id === '') {\n                isMatch = true;\n                break;\n            }\n        }\n        return isMatch;\n    }\n\n    private getSelectListData($column: IColumnDef) {\n        const dataInput = $column.data;\n        if (dataInput instanceof Array) {\n            return this.$q.when(dataInput);\n        } else {\n            return this.$q.when(dataInput && dataInput());\n        }\n    }\n}\nexport { ngTableSelectFilterDs };\n\n\n// WEBPACK FOOTER //\n// ./~/angular1-template-loader!./src/browser/ngTableSelectFilterDs.directive.ts","/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\nconst templateUrl = require('./sorterRow.html');\n\nngTableSorterRow.$inject = [];\n\n/**\n * directive that renders the sorting header row for a table \n * @ngdoc directive\n * @example\n * ```html\n * <ng-table-sorter-row></ng-table-sorter-row>\n * ```\n */\nexport function ngTableSorterRow(){\n    const directive = {\n        restrict: 'E',\n        replace: true,\n        templateUrl: templateUrl,\n        scope: true,\n        controller: 'ngTableSorterRowController',\n        controllerAs: '$ctrl'\n    };\n    return directive;\n}\n\n\n// WEBPACK FOOTER //\n// ./~/angular1-template-loader!./src/browser/ngTableSorterRow.directive.ts","/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\nimport { IAngularEvent } from 'angular';\nimport { SortDirection, ISortingValues } from '../core';\nimport { IColumnDef } from './public-interfaces';\nimport { ITableScope } from './ngTableController';\n\n/**\n * @private\n */\nexport interface IAugmentedMouseEvent extends IAngularEvent {\n    ctrlKey: boolean;\n    metaKey: boolean;\n}\n/**\n * Controller for the {@link ngTableSorterRow ngTableSorterRow} directive\n */\nexport class NgTableSorterRowController<T> {\n    static $inject = ['$scope'];\n    constructor(private $scope: ITableScope<T>) {}\n\n    sortBy($column: IColumnDef, event: IAugmentedMouseEvent) {\n        const parsedSortable = $column.sortable && $column.sortable();\n        if (!parsedSortable || typeof parsedSortable !== 'string') {\n            return;\n        } else {\n            const defaultSort = this.$scope.params.settings().defaultSort;\n            const inverseSort: SortDirection = (defaultSort === 'asc' ? 'desc' : 'asc');\n            const sorting = this.$scope.params.sorting() && this.$scope.params.sorting()[parsedSortable] && (this.$scope.params.sorting()[parsedSortable] === defaultSort);\n            const sortingParams: ISortingValues = (event.ctrlKey || event.metaKey) ? this.$scope.params.sorting() : {};\n            sortingParams[parsedSortable] = (sorting ? inverseSort : defaultSort);\n            this.$scope.params.parameters({\n                sorting: sortingParams\n            });\n        }\n\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./~/angular1-template-loader!./src/browser/ngTableSorterRowController.ts","/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\nimport * as ng1 from 'angular';\nimport { IFilterFilter, IFilterOrderBy, IFilterService, IPromise, IServiceProvider} from 'angular';\nimport { IFilterFunc } from '../filtering';\nimport { NgTableParams } from '../ngTableParams';\nimport { NgTableEventsChannel } from '../ngTableEventsChannel';\n\n\n/**\n * A default implementation of the getData function that will apply the `filter`, `orderBy` and\n * paging values from the {@link NgTableParams} instance supplied to the data array supplied.\n *\n * A call to this function will:\n * - return the resulting array\n * - assign the total item count after filtering to the `total` of the `NgTableParams` instance supplied\n */\nexport interface IDefaultGetData<T> {\n    (data: T[], params: NgTableParams<T>): T[];\n    /**\n     * Convenience function that this service will use to apply paging to the data rows.\n     *\n     * Returns a slice of rows from the `data` array supplied and sets the `NgTableParams.total()`\n     * on the `params` instance supplied to `data.length`\n     */\n    applyPaging(data: T[], params: NgTableParams<any>): T[],\n    /**\n     * Returns a reference to the function that this service will use to filter data rows\n     */\n    getFilterFn(params: NgTableParams<T>): IFilterFunc<T>,\n    /**\n     * Returns a reference to the function that this service will use to sort data rows\n     */\n    getOrderByFn(params?: NgTableParams<T>): IFilterOrderBy\n}\n\n/**\n * Implementation of the {@link IDefaultGetDataProvider} interface\n */\nexport class NgTableDefaultGetDataProvider implements IServiceProvider {\n    /**\n     * The name of a angular filter that knows how to apply the values returned by\n     * `NgTableParams.filter()` to restrict an array of data.\n     * (defaults to the angular `filter` filter service)\n     */\n    filterFilterName = 'filter';\n    /**\n     * The name of a angular filter that knows how to apply the values returned by\n    * `NgTableParams.orderBy()` to sort an array of data.\n    * (defaults to the angular `orderBy` filter service)\n    */\n    sortingFilterName = 'orderBy';\n    $get: ($filter: IFilterService, ngTableEventsChannel: NgTableEventsChannel) => IDefaultGetData<any>;\n    constructor() {\n        const provider = this;\n        this.$get = ngTableDefaultGetData;\n\n        ngTableDefaultGetData.$inject = ['$filter', 'ngTableEventsChannel'];\n\n        function ngTableDefaultGetData<T>($filter: IFilterService, ngTableEventsChannel: NgTableEventsChannel): IDefaultGetData<T> {\n\n            const defaultDataOptions = { applyFilter: true, applySort: true, applyPaging: true };\n\n            (getData as IDefaultGetData<T>).applyPaging = applyPaging;\n            (getData as IDefaultGetData<T>).getFilterFn = getFilterFn;\n            (getData as IDefaultGetData<T>).getOrderByFn = getOrderByFn;\n\n            return getData as IDefaultGetData<T>;\n\n            function getFilterFn(params: NgTableParams<T>): IFilterFunc<T> {\n                const filterOptions = params.settings().filterOptions;\n                if (ng1.isFunction(filterOptions.filterFn)) {\n                    return filterOptions.filterFn;\n                } else {\n                    return $filter<IFilterFilter>(filterOptions.filterFilterName || provider.filterFilterName);\n                }\n            }\n\n            function getOrderByFn(params: NgTableParams<T>) {\n                return $filter<IFilterOrderBy>(provider.sortingFilterName);\n            }\n\n            function applyFilter(data: T[], params: NgTableParams<T>): T[] {\n                if (!params.hasFilter()) {\n                    return data;\n                }\n\n                const filter = params.filter(true);\n                const filterKeys = Object.keys(filter);\n                const parsedFilter = filterKeys.reduce((result, key) => {\n                    result = setPath(result, filter[key], key);\n                    return result;\n                }, {});\n                const filterFn = getFilterFn(params);\n                return filterFn.call(params, data, parsedFilter, params.settings().filterOptions.filterComparator);\n            }\n\n            function applyPaging(data: T[], params: NgTableParams<any>): T[] {\n                const pagedData = data.slice((params.page() - 1) * params.count(), params.page() * params.count());\n                params.total(data.length); // set total for recalc pagination\n                return pagedData;\n            }\n\n            function applySort(data: T[], params: NgTableParams<T>): T[] {\n                const orderBy = params.orderBy();\n                const orderByFn = getOrderByFn(params);\n                return orderBy.length ? orderByFn(data, orderBy) : data;\n            }\n\n            function getData(data: T[], params: NgTableParams<T>): T[] {\n                if (data == null) {\n                    return [];\n                }\n\n                const options = ng1.extend({}, defaultDataOptions, params.settings().dataOptions);\n\n                const fData = options.applyFilter ? applyFilter(data, params) : data;\n                ngTableEventsChannel.publishAfterDataFiltered(params, fData);\n\n                const orderedData = options.applySort ? applySort(fData, params) : fData;\n                ngTableEventsChannel.publishAfterDataSorted(params,orderedData);\n\n                return options.applyPaging ? applyPaging(orderedData, params) : orderedData;\n            }\n\n            // Sets the value at any depth in a nested object based on the path\n            // note: adapted from: underscore-contrib#setPath\n            function setPath(obj: any, value: any, path: string) {\n                const keys = path.split('.');\n                const ret = obj;\n                const lastKey = keys[keys.length - 1];\n                let target = ret;\n\n                const parentPathKeys = keys.slice(0, keys.length - 1);\n                parentPathKeys.forEach(function (key) {\n                    if (!target.hasOwnProperty(key)) {\n                        target[key] = {};\n                    }\n                    target = target[key];\n                });\n\n                target[lastKey] = value;\n                return ret;\n            }\n        }\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/angular1-template-loader!./src/core/data/ngTableDefaultGetData.ts","export * from './filterComparator';\nexport * from './filterFunc';\nexport * from './filterSettings';\n\n\n// WEBPACK FOOTER //\n// ./~/angular1-template-loader!./src/core/filtering/index.ts","export * from './getGroup';\nexport * from './groupingFunc';\nexport * from './groupSettings';\nexport * from './ngTableDefaultGetGroups';\n\n\n// WEBPACK FOOTER //\n// ./~/angular1-template-loader!./src/core/grouping/index.ts","import { IQService } from 'angular';\nimport * as ng1 from 'angular';\nimport { convertSortToOrderBy, isGroupingFun } from '../util';\nimport { NgTableParams,  } from '../ngTableParams';\nimport { IDataRowGroup, IDefaultGetData, IGetDataFunc } from '../data';\nimport { IGetGroupFunc, Grouping, IGroupingFunc, GroupSort } from './';\nimport { ISortingValues } from '../sorting';\n\nngTableDefaultGetGroups.$inject = ['$q', 'ngTableDefaultGetData'];\n\n/**\n * Implementation of the {@link IDefaultGetData IDefaultGetData} interface\n * \n * @ngdoc service\n */\nexport function ngTableDefaultGetGroups<T>($q: IQService, ngTableDefaultGetData: IDefaultGetData<IDataRowGroup<T>>): IGetGroupFunc<T> {\n\n    return getGroups;\n\n    function getGroups(params: NgTableParams<T>) {\n\n        const group = params.group();\n        let groupFn: IGroupingFunc<T>;\n        let sortDirection: GroupSort = undefined;\n        if (isGroupingFun(group)) {\n            groupFn = group;\n            sortDirection = group.sortDirection;\n        } else {\n            // currently support for only one group implemented\n            const groupField = Object.keys(group)[0];\n            sortDirection = group[groupField];\n            groupFn = item => {\n                return getPath(item, groupField);\n            };\n        }\n\n        const settings = params.settings();\n        const originalDataOptions = settings.dataOptions;\n        settings.dataOptions = { applyPaging: false };\n        const getData: IGetDataFunc<T> = settings.getData;\n        const gotData = $q.when(getData(params));\n        return gotData.then(data => {\n            const groups: { [name: string]: IDataRowGroup<T> } = {};\n            ng1.forEach(data, item => {\n                const groupName = groupFn(item);\n                groups[groupName] = groups[groupName] || {\n                    data: [],\n                    $hideRows: !settings.groupOptions.isExpanded,\n                    value: groupName\n                };\n                groups[groupName].data.push(item);\n            });\n            let result: IDataRowGroup<T>[] = [];\n            for (const i in groups) {\n                result.push(groups[i]);\n            }\n            if (sortDirection) {\n                const orderByFn = ngTableDefaultGetData.getOrderByFn();\n                const orderBy = convertSortToOrderBy({\n                    value: sortDirection\n                });\n                result = orderByFn(result, orderBy);\n            }\n\n            return ngTableDefaultGetData.applyPaging(result, params);\n        }).finally(() => {\n            // restore the real options\n            settings.dataOptions = originalDataOptions;\n        });\n    }\n}\n\n\n/**\n * @private\n */\nfunction getPath(obj: { [name: string]: any }, ks: string | string[]): any {\n    // origianl source https://github.com/documentcloud/underscore-contrib\n\n    let keys: string[];\n    if (typeof ks === \"string\") {\n        keys = ks.split(\".\");\n    } else {\n        keys = ks;\n    }\n\n    // If we have reached an undefined property\n    // then stop executing and return undefined\n    if (obj === undefined) return void 0;\n\n    // If the path array has no more elements, we've reached\n    // the intended property and return its value\n    if (keys.length === 0) return obj;\n\n    // If we still have elements in the path array and the current\n    // value is null, stop executing and return undefined\n    if (obj === null) return void 0;\n\n    return getPath(obj[keys[0]], keys.slice(1));\n}\n\n\n// WEBPACK FOOTER //\n// ./~/angular1-template-loader!./src/core/grouping/ngTableDefaultGetGroups.ts","export * from './getGroup';\nexport * from './groupingFunc';\nexport * from './groupSettings';\n\n\n// WEBPACK FOOTER //\n// ./~/angular1-template-loader!./src/core/grouping/publicExports.ts","var path = 'ng-table/filterRow.html';\nvar html = \"<tr ng-show=show_filter class=ng-table-filters> <th data-title-text=\\\"{{$column.titleAlt(this) || $column.title(this)}}\\\" ng-repeat=\\\"$column in $columns\\\" ng-if=$column.show(this) class=\\\"filter {{$column.class(this)}}\\\" ng-class=\\\"params.settings().filterOptions.filterLayout === 'horizontal' ? 'filter-horizontal' : ''\\\"> <div ng-repeat=\\\"(name, filter) in $column.filter(this)\\\" ng-include=$ctrl.config.getTemplateUrl(filter) class=filter-cell ng-class=\\\"[$ctrl.getFilterCellCss($column.filter(this), params.settings().filterOptions.filterLayout), $last ? 'last' : '']\\\"> </div> </th> </tr> \";\nvar angular = require('angular');\nangular.module('ng').run(['$templateCache', function(c) { c.put(path, html) }]);\nmodule.exports = path;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/browser/filterRow.html\n// module id = 42\n// module chunks = 0","var path = 'ng-table/filters/number.html';\nvar html = \"<input type=number name={{name}} ng-disabled=$filterRow.disabled ng-model=params.filter()[name] class=\\\"input-filter form-control\\\" placeholder=\\\"{{getFilterPlaceholderValue(filter, name)}}\\\"/> \";\nvar angular = require('angular');\nangular.module('ng').run(['$templateCache', function(c) { c.put(path, html) }]);\nmodule.exports = path;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/browser/filters/number.html\n// module id = 43\n// module chunks = 0","var path = 'ng-table/filters/select-multiple.html';\nvar html = \"<select ng-options=\\\"data.id as data.title for data in $column.data\\\" ng-disabled=$filterRow.disabled multiple=multiple ng-multiple=true ng-model=params.filter()[name] class=\\\"filter filter-select-multiple form-control\\\" name={{name}}> </select> \";\nvar angular = require('angular');\nangular.module('ng').run(['$templateCache', function(c) { c.put(path, html) }]);\nmodule.exports = path;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/browser/filters/select-multiple.html\n// module id = 44\n// module chunks = 0","var path = 'ng-table/filters/select.html';\nvar html = \"<select ng-options=\\\"data.id as data.title for data in $selectData\\\" ng-table-select-filter-ds=$column ng-disabled=$filterRow.disabled ng-model=params.filter()[name] class=\\\"filter filter-select form-control\\\" name={{name}}> <option style=display:none value=\\\"\\\"></option> </select> \";\nvar angular = require('angular');\nangular.module('ng').run(['$templateCache', function(c) { c.put(path, html) }]);\nmodule.exports = path;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/browser/filters/select.html\n// module id = 45\n// module chunks = 0","var path = 'ng-table/filters/text.html';\nvar html = \"<input type=text name={{name}} ng-disabled=$filterRow.disabled ng-model=params.filter()[name] class=\\\"input-filter form-control\\\" placeholder=\\\"{{getFilterPlaceholderValue(filter, name)}}\\\"/> \";\nvar angular = require('angular');\nangular.module('ng').run(['$templateCache', function(c) { c.put(path, html) }]);\nmodule.exports = path;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/browser/filters/text.html\n// module id = 46\n// module chunks = 0","var path = 'ng-table/groupRow.html';\nvar html = \"<tr ng-if=params.hasGroup() ng-show=$groupRow.show class=ng-table-group-header> <th colspan={{$ctrl.getVisibleColumns().length}} class=sortable ng-class=\\\"{\\n                    'sort-asc': params.hasGroup($selGroup, 'asc'),\\n                    'sort-desc':params.hasGroup($selGroup, 'desc')\\n                  }\\\"> <a href=\\\"\\\" ng-click=\\\"isSelectorOpen = !isSelectorOpen\\\" class=ng-table-group-selector> <strong class=sort-indicator>{{$selGroupTitle}}</strong> <button class=\\\"btn btn-default btn-xs ng-table-group-close\\\" ng-click=\\\"$groupRow.show = false; $event.preventDefault(); $event.stopPropagation();\\\"> <span class=\\\"glyphicon glyphicon-remove\\\"></span> </button> <button class=\\\"btn btn-default btn-xs ng-table-group-toggle\\\" ng-click=\\\"$ctrl.toggleDetail(); $event.preventDefault(); $event.stopPropagation();\\\"> <span class=glyphicon ng-class=\\\"{\\n                    'glyphicon-resize-small': params.settings().groupOptions.isExpanded,\\n                    'glyphicon-resize-full': !params.settings().groupOptions.isExpanded\\n                }\\\"></span> </button> </a> <div class=list-group ng-if=isSelectorOpen> <a href=\\\"\\\" class=list-group-item ng-repeat=\\\"group in $ctrl.getGroupables()\\\" ng-click=$ctrl.groupBy(group)> <strong>{{ $ctrl.getGroupTitle(group)}}</strong> <strong ng-class=\\\"$ctrl.isSelectedGroup(group) && 'sort-indicator'\\\"></strong> </a> </div> </th> </tr> \";\nvar angular = require('angular');\nangular.module('ng').run(['$templateCache', function(c) { c.put(path, html) }]);\nmodule.exports = path;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/browser/groupRow.html\n// module id = 47\n// module chunks = 0","var path = 'ng-table/header.html';\nvar html = \"<ng-table-group-row></ng-table-group-row> <ng-table-sorter-row></ng-table-sorter-row> <ng-table-filter-row></ng-table-filter-row> \";\nvar angular = require('angular');\nangular.module('ng').run(['$templateCache', function(c) { c.put(path, html) }]);\nmodule.exports = path;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/browser/header.html\n// module id = 48\n// module chunks = 0","var path = 'ng-table/pager.html';\nvar html = \"<div class=\\\"ng-cloak ng-table-pager\\\" ng-if=params.data.length> <div ng-if=params.settings().counts.length class=\\\"ng-table-counts btn-group pull-right\\\"> <button ng-repeat=\\\"count in params.settings().counts\\\" type=button ng-class=\\\"{'active':params.count() == count}\\\" ng-click=params.count(count) class=\\\"btn btn-default\\\"> <span ng-bind=count></span> </button> </div> <ul ng-if=pages.length class=\\\"pagination ng-table-pagination\\\"> <li class=page-item ng-class=\\\"{'disabled': !page.active && !page.current, 'active': page.current}\\\" ng-repeat=\\\"page in pages\\\" ng-switch=page.type> <a class=page-link ng-switch-when=prev ng-click=params.page(page.number) href=\\\"\\\">&laquo;</a> <a class=page-link ng-switch-when=first ng-click=params.page(page.number) href=\\\"\\\"><span ng-bind=page.number></span></a> <a class=page-link ng-switch-when=page ng-click=params.page(page.number) href=\\\"\\\"><span ng-bind=page.number></span></a> <a class=page-link ng-switch-when=more ng-click=params.page(page.number) href=\\\"\\\">&#8230;</a> <a class=page-link ng-switch-when=last ng-click=params.page(page.number) href=\\\"\\\"><span ng-bind=page.number></span></a> <a class=page-link ng-switch-when=next ng-click=params.page(page.number) href=\\\"\\\">&raquo;</a> </li> </ul> </div> \";\nvar angular = require('angular');\nangular.module('ng').run(['$templateCache', function(c) { c.put(path, html) }]);\nmodule.exports = path;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/browser/pager.html\n// module id = 49\n// module chunks = 0","var path = 'ng-table/sorterRow.html';\nvar html = \"<tr class=ng-table-sort-header> <th title={{$column.headerTitle(this)}} ng-repeat=\\\"$column in $columns\\\" ng-class=\\\"{\\n                    'sortable': $column.sortable(this),\\n                    'sort-asc': params.sorting()[$column.sortable(this)]=='asc',\\n                    'sort-desc': params.sorting()[$column.sortable(this)]=='desc'\\n                  }\\\" ng-click=\\\"$ctrl.sortBy($column, $event)\\\" ng-if=$column.show(this) ng-init=\\\"template = $column.headerTemplateURL(this)\\\" class=\\\"header {{$column.class(this)}}\\\"> <div ng-if=!template class=ng-table-header ng-class=\\\"{'sort-indicator': params.settings().sortingIndicator == 'div'}\\\"> <span ng-bind=$column.title(this) ng-class=\\\"{'sort-indicator': params.settings().sortingIndicator == 'span'}\\\"></span> </div> <div ng-if=template ng-include=template></div> </th> </tr> \";\nvar angular = require('angular');\nangular.module('ng').run(['$templateCache', function(c) { c.put(path, html) }]);\nmodule.exports = path;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/browser/sorterRow.html\n// module id = 50\n// module chunks = 0","import * as ng1 from 'angular';\nimport { ngTableCoreModule } from './src/core';\nimport { ngTableBrowserModule } from './src/browser';\n\nconst ngTableModule = ng1.module('ngTable', [ngTableCoreModule.name, ngTableBrowserModule.name]);\n\nexport { ngTableModule };\nexport * from './src/core';\nexport * from './src/browser';\n\n\n// WEBPACK FOOTER //\n// ./~/angular1-template-loader!./index.ts"],"sourceRoot":""}